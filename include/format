// -*- C++ -*-
//===--------------------------- format -----------------------------------===//
//
//    Copyright (c) 2018-2019 Duzy Chan at ExtBit Limited.
//    This file is part of ExtC++, the ExtBit C++ standard library.
//
//    <format> implements jtc1/sc22/wg21/docs/papers/2019/p0645r9,
//    insipred by the fmtlib by Victor Zverovich.
//
//===----------------------------------------------------------------------===//
#pragma once
#pragma GCC system_header
#if defined(format_synopsis)
namespace std {
  // [format.error], class format_error
  class format_error;

  // [format.formatter], formatter
  template<class Char> class basic_format_parse_context;
  using format_parse_context = basic_format_parse_context<char>;
  using wformat_parse_context = basic_format_parse_context<wchar_t>;
  
  template<class Out, class Char> class basic_format_context;
  using format_context = basic_format_context<unspecified, char>;
  using wformat_context = basic_format_context<unspecified, wchar_t>;

  template<class T, class Char = char> struct formatter;
  
  // [format.arguments], arguments
  template<class Context> class basic_format_arg;

  template<class Visitor, class Context>
    see below visit_format_arg(Visitor&& vis, basic_format_arg<Context> arg);

  template<class Context, class... Args> struct format_arg_store; // exposition only

  template<class Context> class basic_format_args;
  using format_args = basic_format_args<format_context>;
  using wformat_args = basic_format_args<wformat_context>;

  template<class Out, class Char>
    using format_args_t = basic_format_args<basic_format_context<Out, Char>>;

  template<class Context = format_context, class... Args>
    format_arg_store<Context, Args...>
      make_format_args(const Args&... args);
  template<class... Args>
    format_arg_store<wformat_context, Args...>
      make_wformat_args(const Args&... args);

  // [format.functions], formatting functions
  template<class... Args>
    string format(string_view fmt, const Args&... args);
  template<class... Args>
    wstring format(wstring_view fmt, const Args&... args);

  string vformat(string_view fmt, format_args args);
  wstring vformat(wstring_view fmt, wformat_args args);

  template<class Out, class... Args>
    Out format_to(Out out, string_view fmt, const Args&... args);
  template<class Out, class... Args>
    Out format_to(Out out, wstring_view fmt, const Args&... args);

  template<class Out>
    Out vformat_to(Out out, string_view fmt, format_args_t<Out, char> args);
  template<class Out>
    Out vformat_to(Out out, wstring_view fmt, format_args_t<Out, wchar_t> args);

  template<class Out>
    struct format_to_n_result {
      Out out;
      iter_difference_t<Out> size;
    };
  
  template<class Out, class... Args>
    format_to_n_result<Out> format_to_n(Out out, iter_difference_t<Out> n,
                                        string_view fmt, const Args&... args);
  template<class Out, class... Args>
    format_to_n_result<Out> format_to_n(Out out, iter_difference_t<Out> n,
                                        wstring_view fmt, const Args&... args);

  template<class... Args>
    size_t formatted_size(string_view fmt, const Args&... args);
  template<class... Args>
    size_t formatted_size(wstring_view fmt, const Args&... args);
}
#endif

#include <__config>
#include <stdexcept>
#include <string_view>
#include <string>
#include <stdint.h>
#include <variant>
#include <array>
#include <iostream>

_LIBCPP_BEGIN_NAMESPACE_STD

class format_error : public runtime_error
{
public:
  explicit format_error(const string& message) : runtime_error(message) {}
  explicit format_error(const char* message) : runtime_error(message) {}
};

[[noreturn]] inline _LIBCPP_INLINE_VISIBILITY
void __throw_format_error(const char*__msg)
{
#ifndef _LIBCPP_NO_EXCEPTIONS
    throw format_error(__msg);
#else
    ((void)__msg);
    _VSTD::abort();
#endif
}

template <typename Char>
class basic_format_parse_context {
  basic_string_view<Char> fmt_;
  enum { unknown, manual, automatic } indexing_;
  _VSTD::size_t next_arg_id_;
  _VSTD::size_t num_args_;

  basic_format_parse_context(const basic_format_parse_context&) = delete;
  basic_format_parse_context& operator=(const basic_format_parse_context&) = delete;

public:
  using char_type = Char;
  using const_iterator = typename basic_string_view<Char>::const_iterator;
  using iterator = const_iterator;

  explicit constexpr basic_format_parse_context(basic_string_view<Char> fmt, size_t num_args = 0) noexcept
    : fmt_(fmt), indexing_(unknown), next_arg_id_(0), num_args_(num_args) {}

  constexpr const_iterator begin() const noexcept { return fmt_.begin(); }
  constexpr const_iterator end() const noexcept { return fmt_.end(); }
  constexpr void advance_to(const_iterator it) {
    // Expects: end() is reachable from it.
    // static_cast<make_unsigned_t<?>>(it - begin());
    fmt_.remove_prefix(static_cast<size_t>(it - begin()));
  }

  constexpr int next_arg_id() {
    if (indexing_ == manual)
      __throw_format_error("mixing of automatic and manual argument indexing");
    else if (indexing_ == unknown)
      indexing_ = automatic;
    return next_arg_id_++;
  }

  constexpr void check_arg_id(size_t id) {
    // Expects: next_arg_id_ < num_args_
    if (indexing_ == automatic)
      __throw_format_error("mixing of automatic and manual argument indexing");
    else if (indexing_ == unknown)
      indexing_ = manual;
  }
};

using format_parse_context = basic_format_parse_context<char>;
using wformat_parse_context = basic_format_parse_context<wchar_t>;

template <typename Context> class basic_format_arg;
template <typename Context> class basic_format_args;
template<class T, class Char = char> struct formatter;

template <typename OutIter, typename Char>
class basic_format_context
{
  using format_args = basic_format_args<basic_format_context>;

private:
  OutIter out_;
  format_args args_;

  basic_format_context(const basic_format_context&) = delete;
  void operator=(const basic_format_context&) = delete;

public:
  using char_type = Char;
  using iterator = OutIter;
  using format_arg = basic_format_arg<basic_format_context>;
  template <typename T> using formatter_type = formatter<T,Char>;

  basic_format_context(OutIter out, format_args args)
    : out_(out), args_(args) {}

  format_arg arg(int id) const { return args_.get(id); }
  iterator out() { return out_; }
  void advance_to(iterator it) { out_ = it; }
};

namespace __format
{
  template <typename Iterator>
  inline Iterator&& reserve(Iterator&& it, _VSTD::size_t) { return it; }

  enum class alignment { none, left, right, numeric, center };

  struct data final
  {
    static const uint64_t powers_of_10_64[];
    static const uint32_t zero_or_powers_of_10_32[];
    static const uint64_t zero_or_powers_of_10_64[];
    static const uint64_t pow10_significands[];
    static const int16_t pow10_exponents[];
    static const char digits[];
    static const char hex_digits[];
    template <typename Char> struct basic_color {
      static const Char foreground[];
      static const Char background[];
      static const Char reset[];
    };
    using color = basic_color<char>;
    using wcolor = basic_color<wchar_t>;
    data() = delete;
  };

  template <typename T> struct is_char : _VSTD::false_type {};
  template <> struct is_char<char> : _VSTD::true_type {};
  template <> struct is_char<wchar_t> : _VSTD::true_type {};
  template <> struct is_char<char8_t> : _VSTD::true_type {};
  template <> struct is_char<char16_t> : _VSTD::true_type {};
  template <> struct is_char<char32_t> : _VSTD::true_type {};

  template <typename Char>
  inline constexpr bool is_char_v = is_char<Char>::value;

  template <typename Int> using uint_32_64_t =
    _VSTD::conditional_t<_VSTD::numeric_limits<Int>::digits <= 32,
                         uint32_t, uint64_t>;

  template <typename Int> using uint_32_128_t =
    _VSTD::conditional_t<_VSTD::numeric_limits<Int>::digits <= 64,
                         uint_32_64_t<Int>, __uint128_t>;

  template <typename Int> using uint_best_fit_t = uint_32_128_t<Int>;

  template <typename T, _VSTD::enable_if_t<_VSTD::numeric_limits<T>::is_signed,int> = 0>
  inline constexpr bool is_negative(T value) { return value < 0; }

  template <typename T, _VSTD::enable_if_t<!_VSTD::numeric_limits<T>::is_signed,int> = 0>
  inline constexpr bool is_negative(T) { return false; }
  
# ifdef __has_builtin(__builtin_clz)
  // Returns the number of decimal digits in n. Leading zeros are not counted
  // except for n == 0 in which case count_digits returns 1.
  inline int count_digits(uint64_t n) {
    // Based on http://graphics.stanford.edu/~seander/bithacks.html#IntegerLog10
    // and the benchmark https://github.com/localvoid/cxx-benchmark-count-digits.
    int t = (64 - __builtin_clz(n | 1)) * 1233 >> 12;
    return t - (n < data::zero_or_powers_of_10_64[t]) + 1;
  }
# else
  // Fallback version of count_digits used when __builtin_clz is not available.
  inline int count_digits(uint64_t n) {
    int count = 1;
    for (;;) {
      // Integer division is slow so do it for a group of four digits instead
      // of for every digit. The idea comes from the talk by Alexandrescu
      // "Three Optimization Tips for C++". See speed-test for a comparison.
      if (n < 10) return count;
      if (n < 100) return count + 1;
      if (n < 1000) return count + 2;
      if (n < 10000) return count + 3;
      n /= 10000u;
      count += 4;
    }
  }
# endif

  // Counts the number of digits in n. BITS = log2(radix).
  template <unsigned BITS, typename UInt>
  inline int count_digits(UInt n) {
    int num_digits = 0;
    do {
      ++num_digits;
    } while ((n >>= BITS) != 0);
    return num_digits;
  }

  template <> int count_digits<4>(_VSTD::uintptr_t n);

  template <typename Char, typename FormatContext, typename Value>
  inline void format_char(FormatContext& fc, Value value) {
    auto out = fc.out();
    *out++ = static_cast<Char>(value);
    fc.advance_to(out);
  }

  template <typename FormatContext, typename Int>
  void format_decimal(FormatContext& fc, Int value) {
    using char_type = typename FormatContext::char_type;
    using uint_type = uint_best_fit_t<Int>;
    auto absvalue = static_cast<uint_type>(value);
    auto negative = is_negative(value);
    auto num_digits = 0;
    auto out = fc.out();
    if (negative) {
      absvalue = 0 - absvalue;
      num_digits = count_digits(absvalue);
      reserve(out, static_cast<_VSTD::size_t>(num_digits) + 1);
      *out++ = static_cast<char_type>('-');
    } else {
      num_digits = count_digits(absvalue);
      reserve(out, static_cast<_VSTD::size_t>(num_digits));
    }
    assert(num_digits >= 0 && "bad number of digits");
    enum {
          // '-' and digits
          base_size = _VSTD::numeric_limits<uint_type>::digits10 + 1,
          // base size and thousands separators
          buffer_size = base_size + base_size / 3,
    };
    char_type buffer[buffer_size];
    auto end = buffer + buffer_size;
    auto ptr = end;
    while (absvalue >= 100) {
      // Integer division is slow so do it for a group of two digits instead
      // of for every digit. The idea comes from the talk by Alexandrescu
      // "Three Optimization Tips for C++". See speed-test for a comparison.
      //     -- fmtlib by Victor Zverovich
      unsigned index = static_cast<unsigned>((absvalue % 100) * 2);
      absvalue /= 100;
      *--ptr = static_cast<char_type>(data::digits[index + 1]);
      //add_thousands_sep(ptr);
      *--ptr = static_cast<char_type>(data::digits[index]);
      //add_thousands_sep(ptr);
    }
    if (absvalue < 10) {
      *--ptr = static_cast<char_type>('0' + absvalue);
    } else {
      unsigned index = static_cast<unsigned>(absvalue * 2);
      *--ptr = static_cast<char_type>(data::digits[index + 1]);
      //add_thousands_sep(buffer);
      *--ptr = static_cast<char_type>(data::digits[index]);
    }
    fc.advance_to(_VSTD::copy(ptr, end, out));
  }

  template<typename T> struct handle {
#if __has_feature(ASSOCIATED_TYPENAME_SPECIALIZATION)
    handle() = delete;
#else
    template<typename ParseContext, typename FormatContext>
    void format(ParseContext& pc, FormatContext& fc, typename basic_format_arg<FormatContext>::handle h) const {
      h.format(pc, fc);
    }
#endif // ASSOCIATED_TYPENAME_SPECIALIZATION
  };
  template<> struct handle<_VSTD::monostate> {
    template<typename ParseContext, typename FormatContext>
    void format(ParseContext& pc, FormatContext& fc, _VSTD::monostate) const {}
  };
  template<> struct handle<char> {
    template<typename ParseContext, typename FormatContext>
    void format(ParseContext& pc, FormatContext& fc, char val) const {
      format_char<typename FormatContext::char_type>(fc, val);
    }
  };
  template<> struct handle<wchar_t> {
    template<typename ParseContext, typename FormatContext>
    void format(ParseContext& pc, FormatContext& fc, wchar_t val) const {
      format_char<typename FormatContext::char_type>(fc, val);
    }
  };
  template<> struct handle<signed int> {
    template<typename ParseContext, typename FormatContext>
    void format(ParseContext& pc, FormatContext& fc, signed int val) const {
      format_decimal(fc, val);
    }
  };
  template<> struct handle<unsigned int> {
    template<typename ParseContext, typename FormatContext>
    void format(ParseContext& pc, FormatContext& fc, unsigned int val) const {
      format_decimal(fc, val);
    }
  };
  template<> struct handle<signed long long> {
    template<typename ParseContext, typename FormatContext>
    void format(ParseContext& pc, FormatContext& fc, signed long long val) const {
      format_decimal(fc, val);
    }
  };
  template<> struct handle<unsigned long long> {
    template<typename ParseContext, typename FormatContext>
    void format(ParseContext& pc, FormatContext& fc, unsigned long long val) const {
      format_decimal(fc, val);
    }
  };
  template<> struct handle<double> {
    template<typename ParseContext, typename FormatContext>
    void format(ParseContext& pc, FormatContext& fc, double) const {
      _VSTD::clog<<"TODO: "<<"double"<<endl;
    }
  };
  template<> struct handle<long double> {
    template<typename ParseContext, typename FormatContext>
    void format(ParseContext& pc, FormatContext& fc, long double) const {
      _VSTD::clog<<"TODO: "<<"long double"<<endl;
    }
  };
  template<typename T> struct handle<_VSTD::basic_string_view<T>> {
    template<typename ParseContext, typename FormatContext>
    void format(ParseContext& pc, FormatContext& fc, _VSTD::basic_string_view<T> val) const {
      _VSTD::copy(val.begin(), val.end(), fc.out());
    }
  };
  template<> struct handle<bool> {
    template<typename ParseContext, typename FormatContext>
    void format(ParseContext& pc, FormatContext& fc, bool val) const {
      using view = _VSTD::string_view;
      handle<view>().format(pc, fc, view(val ? "true" : "false"));
    }
  };
  template<> struct handle<const char*> {
    template<typename ParseContext, typename FormatContext>
    void format(ParseContext& pc, FormatContext& fc, const char* val) const {
      using view = _VSTD::basic_string_view<char>;
      handle<view>().format(pc, fc, view(val));
    }
  };
  template<> struct handle<const wchar_t*> {
    template<typename ParseContext, typename FormatContext>
    void format(ParseContext& pc, FormatContext& fc, const wchar_t* val) const {
      using view = _VSTD::basic_string_view<wchar_t>;
      handle<view>().format(pc, fc, view(val));
    }
  };
  template<> struct handle<const void*> {
    template<typename ParseContext, typename FormatContext>
    void format(ParseContext& pc, FormatContext& fc, const void* val) const {
      _VSTD::clog<<"TODO: (const void*) "<<val<<endl;
    }
  };

  template <typename OutIter, typename Char> class driver final {
    basic_format_context<OutIter,Char> format_context;

    template <typename Iterator>
    void chars(Iterator& pos, const Iterator end) {
      auto out = _VSTD::copy(pos, end, format_context.out());
      format_context.advance_to(out);
    }

    void escape(Char character) {
      auto out = format_context.out();
      *out = character;
      ++out;
      format_context.advance_to(out);
    }

    template <typename Iterator>
    int positive_int(Iterator& pos, const Iterator end) {
      assert(pos != end && '0' <= *pos && *pos <= '9');
      if (*pos == '0') {
        ++pos;
        return 0;
      }
      unsigned val = 0;
      unsigned max = std::numeric_limits<int>::max();
      unsigned top = max / 10;
      do {
        val = val * 10 + unsigned(*pos - '0');
        ++pos;
        if (val > top) { // overflow
          val = top + 1;
          break;
        }
      } while (pos != end && '0' <= *pos && *pos <= '9');
      return static_cast<int>(val);
    }

    template <typename ParseContext, typename Iterator>
    auto arg_id(ParseContext& pc, Iterator& pos, const Iterator end) {
      _VSTD::size_t id;
      auto c = *pos;
      if ('0' <= c && c <= '9') {
        id = this->positive_int(pos, end);
        pc.check_arg_id(id);
      } else {
        id = pc.next_arg_id();
      }
      return id;
    }

    template <typename ParseContext, typename Iterator>
    void replacement(ParseContext& pc, Iterator& pos, const Iterator end) {
      _VSTD::clog<<"replacement: "<<string(pos, end)<<endl;
      assert(*pos == '{' && "unexpected replacement openning");
      ++pos;
      if (pos == end) {
        __throw_format_error("malform format string");
      }
      const auto id = this->arg_id(pc, pos, end);
      if (pos == end) {
        __throw_format_error("malform format string");
      } else if (*pos == ':') {
        ++pos;
        this->spec(pc, id, pos, end);
      } else if (*pos == '}') {
        ++pos;
        this->replace(pc, format_context.arg(id));
      } else {
        __throw_format_error("malform format replacement");
      }
    }

    template <typename ParseContext, typename Iterator>
    void spec(ParseContext& pc, _VSTD::size_t id, Iterator& pos, const Iterator end) {
      if (pos == end) {
        __throw_format_error("malform format replacement spec");
      } else if (*pos == '}') {
        ++pos;
        this->replace(pc, format_context.arg(id));
        return;
      }
      _VSTD::remove_cvref_t<decltype(*pos)> fill = 0;
      auto align = alignment::none;
      auto next = pos + 1;
      if (next != end) {
        switch (*next) {
        case '<': align = alignment::left;
        case '>': align = alignment::right;
        case '=': align = alignment::numeric;
        case '^': align = alignment::center;
        }
        if (align != alignment::none) {
          fill = *pos;
          if (fill == '{')
            __throw_format_error("invalid fill character '{'");
          pos += 2;
          if (pos == end) {
            __throw_format_error("malform format replacement spec");
          }
        }
      }
      auto sign = *pos;
      if (sign == '+' || sign == '-' || sign == ' ') {
        ++pos;
      } else {
        sign = 0;
      }
      auto sharp = false, zero = false;
      if (pos == end) {
        __throw_format_error("malform format replacement spec");
      } else if (*pos == '#') {
        ++pos;
        sharp = true;
      }
      if (pos == end) {
        __throw_format_error("malform format replacement spec");
      } else if (*pos == '0') {
        ++pos;
        zero = true;
      }
      unsigned width = 0, precision = 0;
      if (pos == end) {
        __throw_format_error("malform format replacement spec");
      } else if ('1' <= *pos && *pos <= '9') {
        width = positive_int(pos, end);
        if (pos != end && *pos == '.') {
          ++pos;
          if (pos == end) {
            __throw_format_error("malform format replacement spec");
          } else {
            precision = positive_int(pos, end);
          }
        }
      }
      if (pos == end)
        __throw_format_error("malform format replacement spec");
      const auto type = *pos;
      ++pos;
      if (type == '}') {
        this->general(pc, id, align, fill, width, precision, false);
        return;
      }
      if (*pos != '}') {
        __throw_format_error("malform format replacement spec");
      } else {
        ++pos;
        switch (type) {
        case 'a':
          this->hex(pc, id, align, fill, width, precision, false);
          break;
        case 'A':
          this->hex(pc, id, align, fill, width, precision, true);
          break;
        case 'b':
          this->binary(pc, id, align, fill, width, precision, false);
          break;
        case 'B':
          this->binary(pc, id, align, fill, width, precision, true);
          break;
        case 'c':
          this->character(pc, id, align, fill, width, precision);
          break;
        case 'd':
          this->decimal(pc, id, align, fill, width, precision);
          break;
        case 'e':
          this->scientific(pc, id, align, fill, width, precision, false);
          break;
        case 'E':
          this->scientific(pc, id, align, fill, width, precision, true);
          break;
        case 'f':
          this->fixed(pc, id, align, fill, width, precision, false);
          break;
        case 'F':
          this->fixed(pc, id, align, fill, width, precision, true);
          break;
        case 'g':
          this->general(pc, id, align, fill, width, precision, false);
          break;
        case 'G':
          this->general(pc, id, align, fill, width, precision, true);
          break;
        case 'n':
          this->general_n(pc, id, align, fill, width, precision);
          break;
        case 'o':
          this->octal(pc, id, align, fill, width, precision);
          break;
        case 'p':
          this->ptr(pc, id, align, fill, width, precision);
          break;
        case 's':
          this->str(pc, id, align, fill, width, precision);
          break;
        case 'x':
          this->hex(pc, id, align, fill, width, precision, false);
          break;
        case 'X':
          this->hex(pc, id, align, fill, width, precision, true);
          break;
        }
      }
    }

    template <typename ParseContext, typename FormatArg>
    void replace(ParseContext& pc, FormatArg arg) {
      handle<FormatArg>().format(pc, format_context, arg);
      //format_context.advance_to(out);
    }

    template <typename ParseContext, typename Fill>
    void general(ParseContext& pc, _VSTD::size_t id, alignment align, Fill fill, unsigned width, unsigned precision, bool upper) {
      _VSTD::clog<<"TODO:general: "<<id<<endl;
    }

    template <typename ParseContext, typename Fill>
    void general_n(ParseContext& pc, _VSTD::size_t id, alignment align, Fill fill, unsigned width, unsigned precision) {
      _VSTD::clog<<"TODO:general_n: "<<id<<endl;
    }

    template <typename ParseContext, typename Fill>
    void binary(ParseContext& pc, _VSTD::size_t id, alignment align, Fill fill, unsigned width, unsigned precision, bool upper) {
      _VSTD::clog<<"TODO:binary: "<<id<<endl;
    }

    template <typename ParseContext, typename Fill>
    void decimal(ParseContext& pc, _VSTD::size_t id, alignment align, Fill fill, unsigned width, unsigned precision) {
      _VSTD::clog<<"TODO:decimal: "<<id<<endl;
    }

    template <typename ParseContext, typename Fill>
    void octal(ParseContext& pc, _VSTD::size_t id, alignment align, Fill fill, unsigned width, unsigned precision) {
      _VSTD::clog<<"TODO:octal: "<<id<<endl;
    }

    template <typename ParseContext, typename Fill>
    void hex(ParseContext& pc, _VSTD::size_t id, alignment align, Fill fill, unsigned width, unsigned precision, bool upper) {
      _VSTD::clog<<"TODO:hex: "<<id<<endl;
    }

    template <typename ParseContext, typename Fill>
    void scientific(ParseContext& pc, _VSTD::size_t id, alignment align, Fill fill, unsigned width, unsigned precision, bool upper) {
      _VSTD::clog<<"TODO:scientific: "<<id<<endl;
    }

    template <typename ParseContext, typename Fill>
    void fixed(ParseContext& pc, _VSTD::size_t id, alignment align, Fill fill, unsigned width, unsigned precision, bool upper) {
      _VSTD::clog<<"TODO:fixed: "<<id<<endl;
    }

    template <typename ParseContext, typename Fill>
    void character(ParseContext& pc, _VSTD::size_t id, alignment align, Fill fill, unsigned width, unsigned precision) {
      _VSTD::clog<<"TODO:character: "<<id<<endl;
    }

    template <typename ParseContext, typename Fill>
    void str(ParseContext& pc, _VSTD::size_t id, alignment align, Fill fill, unsigned width, unsigned precision) {
      _VSTD::clog<<"TODO:str: "<<id<<endl;
    }

    template <typename ParseContext, typename Fill>
    void ptr(ParseContext& pc, _VSTD::size_t id, alignment align, Fill fill, unsigned width, unsigned precision) {
      _VSTD::clog<<"TODO:ptr: "<<id<<endl;
    }

  public:
    template <typename FormatArgs>
    driver(OutIter out, FormatArgs args) : format_context(out, args) {}

    template <typename ParseContext>
    constexpr OutIter operator()(ParseContext& context) {
      using char_type = typename ParseContext::char_type;
      auto const end = context.end();
      auto pos = context.begin();
      auto last = pos;
      while (pos != end) {
        switch (*pos) {
        case '{': {
          if (last < pos) this->chars(last, pos);
          auto next = pos + 1;
          if (next == end) {
            // finish
          } else if (*next == '{') {
            ++next;
            this->escape(*pos);
            pos = next;
          } else {
            this->replacement(context, pos, end);
          }
          last = pos;
        } break;
        case '}': { // unbalanced close brace
          if (last < pos) this->chars(last, pos);
          auto next = pos + 1;
          if (next == end) {
            pos = end; // finish
          } else if (*next == '}') {
            ++next;
            this->escape(*pos);
            last = pos = next;
          } else {
            this->chars(pos, next);
            last = pos = end;
          }
        } break;
        default: ++pos;
        }
      }
      if (last < pos) this->chars(last, pos);
      context.advance_to(pos);
      return format_context.out();
    }
  };

  template <typename Char>
  class basic_string_inserter
    : public _VSTD::back_insert_iterator<_VSTD::basic_string<Char>>
  {
  public:
    explicit basic_string_inserter(_VSTD::basic_string<Char>& __x)
      : _VSTD::back_insert_iterator<_VSTD::basic_string<Char>>(__x) {}
    void reserve(_VSTD::size_t size) { this->container->reserve(size); }
  };

  template <typename Char>
  using basic_string_format_context = basic_format_context<basic_string_inserter<Char>,Char>;
} // __format

using format_context = __format::basic_string_format_context<char>;
using wformat_context = __format::basic_string_format_context<wchar_t>;

template<class T, class Char> struct formatter
{
  // T is unsupported by standard formatter, you have to specialize
  // std::formatter<T,Char> in your code.
  formatter() = delete;
};

namespace __format
{
  // selecting smaller type

  template <typename T, typename... Types> struct smaller;
  template <typename T, typename Type>
  struct smaller<T,Type> { using type = Type; };

  template <typename T, typename Type, typename... Rest>
  struct smaller<T,Type,Rest...> : conditional_t<(sizeof(T)<=sizeof(Type)),
    smaller<T,Type>, smaller<T,Rest...>> {};

  template <typename T, typename... Types>
  using smaller_t = typename smaller<T,Types...>::type;

# if 0
  template <typename T, bool = _VSTD::is_integral_v<T>> struct integer
  {
    using Int = _VSTD::conditional_t<
      _VSTD::is_unsigned_v<T>,
      smaller_t<T,unsigned int,unsigned long long int>,
      smaller_t<T,int,long long int>>;
    Int val(const T& v) noexcept { return static_cast<Int>(v); }
  };
# endif

  // integer

  template <typename T, bool = _VSTD::is_unsigned_v<T>>
  struct fit_integer
  {
    using type = smaller_t<T,unsigned int,unsigned long long int>;
  };
  template <typename T> struct fit_integer<T,false>
  {
    using type = smaller_t<T,int,long long int>;
  };
} // __format

template<class Context, class... Args> struct format_arg_store;

template<class Context> class basic_format_arg {
public:
  class handle;

private:
  using char_type = typename Context::char_type;

  _VSTD::variant<
    _VSTD::monostate, bool, char_type, int, unsigned int,
    long long int, unsigned long long int, double, long double,
    const char_type*, basic_string_view<char_type>,
    const void*, handle> var;

  template<class X, class... Args>
  friend struct format_arg_store;

  // integer

  template <typename T, bool = _VSTD::is_integral_v<T>>
  struct integer : __format::fit_integer<T>
  {
    using typename __format::fit_integer<T>::type;
    type val(const T& v) noexcept { return static_cast<type>(v); }
  };

  template <typename T> struct integer<T,false> {
    handle val(const T& v) noexcept { return handle(v); }
  };

  template<class T> explicit basic_format_arg(const T& v) noexcept
    : var(integer<T>().val(v)) {}

  explicit basic_format_arg(float n) noexcept : var(static_cast<double>(n)) {}
  explicit basic_format_arg(double n) noexcept : var(n) {}
  explicit basic_format_arg(long double n) noexcept : var(n) {}
  explicit basic_format_arg(const char_type* s) : var(s) {}

  template<class Traits>
  explicit basic_format_arg(basic_string_view<char_type,Traits> s) noexcept
    : var(s) {}

  template<class Traits, class Allocator>
  explicit basic_format_arg(const basic_string<char_type,Traits,Allocator>& s) noexcept
    : basic_format_arg(basic_string_view(s.data(), s.size())) {}

  explicit basic_format_arg(nullptr_t) noexcept
    : var(static_cast<const void*>(nullptr)) {}

  explicit basic_format_arg(const void* p) noexcept
    : var(p) {}

  template<class Visitor, class Ctx>
  friend auto visit_format_arg(Visitor&& visit, basic_format_arg<Ctx> arg)
    -> decltype(visit(0));

  template<class Ctx, class... Args>
  friend format_arg_store<Ctx, Args...> make_format_args(const Args&... args);

public:
  basic_format_arg() noexcept {}
  explicit operator bool() const noexcept {
    return !_VSTD::holds_alternative<_VSTD::monostate>(var);
  }
};

template<class Context>
class basic_format_arg<Context>::handle {
  friend class basic_format_arg<Context>;

  using char_type = typename Context::char_type;
  using parse_context = basic_format_parse_context<char_type>;

  template<typename T>
  using formatter = typename Context::template formatter_type<T>;

  const void* ptr;
  void (*fmt)(parse_context&, Context&, const void*);

  template<class T> explicit handle(const T& val) noexcept
    : ptr(&val)
    , fmt([](parse_context& parse_ctx, Context& format_ctx, const void* ptr) {
        formatter<T> __f;
        auto& val = *static_cast<const T*>(ptr);
        parse_ctx.advance_to(__f.parse(parse_ctx));
        format_ctx.advance_to(__f.format(val, format_ctx));
      })
  {}

public:
  void format(parse_context& parse_ctx, Context& format_ctx) const
  { fmt(parse_ctx, format_ctx, ptr); }
};

namespace __format
{
  template<typename T> struct handle<basic_format_arg<T>> {
    template<typename ParseContext, typename FormatContext>
    void format(ParseContext& pc, FormatContext& fc, basic_format_arg<T> arg) const {
      visit_format_arg([this, &pc, &fc](const auto& val){
        using char_type = typename FormatContext::char_type;
        using val_type = _VSTD::remove_cvref_t<decltype(val)>;
        handle<val_type>().format(pc, fc, val);
      }, arg);
    }
  };
#if __has_feature(ASSOCIATED_TYPENAME_SPECIALIZATION)
  template<typename FormatContext>
  struct handle<typename basic_format_arg<FormatContext>::handle> {
    template<typename ParseContext>
    void format(ParseContext& pc, FormatContext& fc, typename basic_format_arg<FormatContext>::handle h) const {
      h.format(pc, fc);
    }
  };
#endif // ASSOCIATED_TYPENAME_SPECIALIZATION
}

#if false

namespace __format
{
  template<class Ret, class Visitor, typename... Types> struct visit_by_type;
  template<class Ret, class Visitor> struct visit_by_type<Ret, Visitor>
  {
    template<class Ctx>
    Ret apply(Visitor&& visit, basic_format_arg<Ctx> arg)
    { return visit(monostate()); }
  };

  template<class Ret, class Visitor, typename T, typename... Rest>
  struct visit_by_type<Ret, Visitor, T, Rest...>
  {
    template<class Ctx>
    Ret apply(Visitor&& visit, basic_format_arg<Ctx> arg)
    {
      if (arg.type == &typeid(T))
        return visit(*reinterpret_cast<T*>(&arg.int_value));
      else
        return visit_by_type<Ret,Visitor,Rest...>().apply(visit, arg);
    }
  };
} // __format

template<class Visitor, class Ctx> inline auto
visit_format_arg(Visitor&& visitor, basic_format_arg<Ctx> arg)
  -> decltype(visitor(0))
{
  using handle = typename basic_format_arg<Ctx>::handle;
  using char_type = typename basic_format_arg<Ctx>::char_type;
  __format::visit_by_type
    <decltype(visitor(0)), Visitor,
     monostate, bool, char_type, int, unsigned int,
     long long int, unsigned long long int, double, long double,
     const char_type*, basic_string_view<char_type>,
     const void*, handle> by_type;
  return by_type.apply(move(visitor), arg);
}

#else

template<class Visitor, class Ctx> inline auto
visit_format_arg(Visitor&& visitor, basic_format_arg<Ctx> arg)
  -> decltype(visitor(0))
{ return _VSTD::visit(move(visitor), arg.var); }

#endif

namespace __format
{
  template <typename Char> inline basic_string_inserter<Char>&&
  reserve(basic_string_inserter<Char>&& it, _VSTD::size_t size) {
    it.reserve(size);
    return move(it);
  }

  inline char8_t to_char8_t(char c) { return static_cast<char8_t>(c); }

  template <typename InputIt, typename OutChar>
  constexpr const bool needs_conversion = _VSTD::bool_constant<
    _VSTD::is_same<typename _VSTD::iterator_traits<InputIt>::value_type, char>::value &&
    _VSTD::is_same<OutChar, char8_t>::value>::value;

  template <typename OutChar, typename InputIt, typename OutputIt,
            _VSTD::enable_if_t<!needs_conversion<InputIt,OutChar>,int> = 0>
  OutputIt copy_str(InputIt begin, InputIt end, OutputIt it) {
    return _VSTD::copy(begin, end, it);
  }

  template <typename OutChar, typename InputIt, typename OutputIt,
            _VSTD::enable_if_t<needs_conversion<InputIt,OutChar>,int> = 0>
  OutputIt copy_str(InputIt begin, InputIt end, OutputIt it) {
    return _VSTD::transform(begin, end, it, to_char8_t);
  }

} // __format

template<class Context, class... Args>
struct format_arg_store {
  _VSTD::array<basic_format_arg<Context>,sizeof...(Args)> args;
  format_arg_store(const Args&... args)
    : args{ basic_format_arg<Context>(args)... } {}
};

template<class Context = format_context, class... Args>
inline format_arg_store<Context,Args...>
make_format_args(const Args&... args) { return {args...}; }

template<class... Args>
inline format_arg_store<wformat_context,Args...>
make_wformat_args(const Args&... args) { return {args...}; }

template<class Context> class basic_format_args {
  const basic_format_arg<Context>* args;
  size_t num_args;

public:
  basic_format_args() noexcept;

  template<class... Args>
  basic_format_args(const format_arg_store<Context,Args...>& store) noexcept
    : args(store.args.data()), num_args(store.args.size()) {}

  basic_format_arg<Context> get(_VSTD::size_t i) const noexcept
  { return i < num_args ? args[i] : basic_format_arg<Context>(); }
};

#if 0
template<typename T,typename Char>
struct formatter<T,Char>
{
  template <typename FormatContext>
  constexpr typename FormatContext::iterator
  format(FormatContext& context) {
    auto specifier = this->parsed_specifier();
    if (specifier) specifier->write(context, 0);
    return context.out();
  }
};
#endif

namespace __format
{
  template<typename Char>
  using basic_string_format_args = basic_format_args<basic_string_format_context<Char>>;

  void as_string_view(...);

  template<typename Char, _VSTD::enable_if<is_char_v<Char>>>
  inline basic_string_view<Char>
  as_string_view(const Char* s) { return {s}; }

  template<typename Char, typename Traits, typename Allocator>
  inline basic_string_view<Char>
  as_string_view(const _VSTD::basic_string<Char,Traits,Allocator>& s)
  { return {s.data(), s.size()}; }

  template<typename Char, typename Traits>
  inline basic_string_view<Char>
  as_string_view(basic_string_view<Char,Traits> s)
  { return {s.data(), s.size()}; }

  template <typename S>
  struct is_string : _VSTD::is_class<decltype(as_string_view(_VSTD::declval<S>()))> {};

  template <> struct is_string<void> : _VSTD::false_type {};

  template<typename S>
  inline constexpr bool is_string_v = is_string<S>::value;

  template<typename S, typename=void> struct associated_char {};
  template<typename S> struct associated_char<S,_VSTD::enable_if_t<is_string_v<S>>> {
    using string_view = decltype(as_string_view(_VSTD::declval<S>()));
    using type = typename string_view::value_type;
  };

  template <typename S>
  using char_t = typename associated_char<S>::type;
} // __format

using format_args = __format::basic_string_format_args<char>;
using wformat_args = __format::basic_string_format_args<wchar_t>;

template<typename Out, typename Char>
using format_args_t = basic_format_args<basic_format_context<Out,Char>>;

template<typename Out, typename S, typename Char = __format::char_t<S>>
inline Out vformat_to(Out out, const S& fmt, format_args_t<Out,Char> args)
{
  basic_format_parse_context<Char> parse_context(fmt);
  __format::driver<Out,Char> drive(out, args);
  return drive(parse_context);
}

template<class S, class Context, typename Char = __format::char_t<S>>
inline auto vformat(const S& fmt, basic_format_args<Context> args) {
  _VSTD::basic_string<Char> buffer;
  __format::basic_string_inserter<Char> out(buffer);
  vformat_to(out, fmt, args);
  return buffer;
}

template<typename S, typename... Args, typename Char = __format::char_t<S>>
inline auto format(const S& fmt, const Args&... args) {
  using Context = __format::basic_string_format_context<Char>;
  auto store = make_format_args<Context>(args...);
  const basic_format_args<Context> va(store);
  return vformat(fmt, va);
}

template<typename Char, int N, class... Args>
inline auto format(const Char fmt[N], const Args&... args) {
# if 0
  return format(__format::as_string_view(fmt), args...);
# else
  return format(_VSTD::basic_string_view<Char>(fmt,N), args...);
# endif
}

template<typename Char, class... Args>
inline auto format(const Char* fmt, const Args&... args) {
# if 0
  return format(__format::as_string_view(fmt), args...);
# else
  return format(_VSTD::basic_string_view<Char>(fmt), args...);
# endif
}

_LIBCPP_END_NAMESPACE_STD
