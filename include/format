// -*- C++ -*-
//===--------------------------- format -----------------------------------===//
//
//    Copyright (c) 2018-2019 Duzy Chan at ExtBit Limited.
//    This file is part of ExtC++, the ExtBit C++ standard library.
//
//    <format> implements jtc1/sc22/wg21/docs/papers/2019/p0645r9,
//    insipred by the fmtlib by Victor Zverovich.
//
//===----------------------------------------------------------------------===//
#pragma once
#pragma GCC system_header
#if defined(format_synopsis)
namespace std {
  // [format.error], class format_error
  class format_error;

  // [format.formatter], formatter
  template<class Char> class basic_format_parse_context;
  using format_parse_context = basic_format_parse_context<char>;
  using wformat_parse_context = basic_format_parse_context<wchar_t>;
  
  template<class Out, class Char> class basic_format_context;
  using format_context = basic_format_context<unspecified, char>;
  using wformat_context = basic_format_context<unspecified, wchar_t>;

  template<class T, class Char = char> struct formatter;
  
  // [format.arguments], arguments
  template<class Context> class basic_format_arg;

  template<class Visitor, class Context>
    see_below visit_format_arg(Visitor&& vis, basic_format_arg<Context> arg);

  template<class Context, class... Args> struct format_arg_store; // exposition only

  template<class Context> class basic_format_args;
  using format_args = basic_format_args<format_context>;
  using wformat_args = basic_format_args<wformat_context>;

  template<class Out, class Char>
    using format_args_t = basic_format_args<basic_format_context<Out, Char>>;

  template<class Context = format_context, class... Args>
    format_arg_store<Context, Args...>
      make_format_args(const Args&... args);
  template<class... Args>
    format_arg_store<wformat_context, Args...>
      make_wformat_args(const Args&... args);

  // [format.functions], formatting functions
  template<class... Args>
    string format(string_view fmt, const Args&... args);
  template<class... Args>
    wstring format(wstring_view fmt, const Args&... args);

  string vformat(string_view fmt, format_args args);
  wstring vformat(wstring_view fmt, wformat_args args);

  template<class Out, class... Args>
    Out format_to(Out out, string_view fmt, const Args&... args);
  template<class Out, class... Args>
    Out format_to(Out out, wstring_view fmt, const Args&... args);

  template<class Out>
    Out vformat_to(Out out, string_view fmt, format_args_t<Out, char> args);
  template<class Out>
    Out vformat_to(Out out, wstring_view fmt, format_args_t<Out, wchar_t> args);

  template<class Out>
    struct format_to_n_result {
      Out out;
      iter_difference_t<Out> size;
    };
  
  template<class Out, class... Args>
    format_to_n_result<Out> format_to_n(Out out, iter_difference_t<Out> n,
                                        string_view fmt, const Args&... args);
  template<class Out, class... Args>
    format_to_n_result<Out> format_to_n(Out out, iter_difference_t<Out> n,
                                        wstring_view fmt, const Args&... args);

  template<class... Args>
    size_t formatted_size(string_view fmt, const Args&... args);
  template<class... Args>
    size_t formatted_size(wstring_view fmt, const Args&... args);
}
#endif

#include <__config>
#include <charconv>
#include <stdexcept>
#include <string_view>
#include <string>
#include <stdint.h>
#include <variant>
#include <array>
#include <iostream>

_LIBCPP_BEGIN_NAMESPACE_STD

class format_error : public runtime_error
{
public:
  explicit format_error(const string& message) : runtime_error(message) {}
  explicit format_error(const char* message) : runtime_error(message) {}
};

[[noreturn]] inline _LIBCPP_INLINE_VISIBILITY
void __throw_format_error(const char*__msg)
{
#ifndef _LIBCPP_NO_EXCEPTIONS
    throw format_error(__msg);
#else
    ((void)__msg);
    _VSTD::abort();
#endif
}

template <typename Char>
class basic_format_parse_context {
  basic_string_view<Char> fmt_;
  enum { unknown, manual, automatic } indexing_;
  size_t next_arg_id_;
  size_t num_args_;

  basic_format_parse_context(const basic_format_parse_context&) = delete;
  basic_format_parse_context& operator=(const basic_format_parse_context&) = delete;

public:
  using char_type = Char;
  using const_iterator = typename basic_string_view<Char>::const_iterator;
  using iterator = const_iterator;

  explicit constexpr basic_format_parse_context(basic_string_view<Char> fmt, size_t num_args = 0) noexcept
    : fmt_(fmt), indexing_(unknown), next_arg_id_(0), num_args_(num_args) {}

  constexpr const_iterator begin() const noexcept { return fmt_.begin(); }
  constexpr const_iterator end() const noexcept { return fmt_.end(); }
  constexpr void advance_to(const_iterator it) {
    // Expects: end() is reachable from it.
    // static_cast<make_unsigned_t<?>>(it - begin());
    fmt_.remove_prefix(static_cast<size_t>(it - begin()));
  }

  constexpr int next_arg_id() {
    if (indexing_ == manual)
      __throw_format_error("mixing of automatic and manual argument indexing");
    else if (indexing_ == unknown)
      indexing_ = automatic;
    return next_arg_id_++;
  }

  constexpr void check_arg_id(size_t id) {
    // Expects: next_arg_id_ < num_args_
    if (indexing_ == automatic)
      __throw_format_error("mixing of automatic and manual argument indexing");
    else if (indexing_ == unknown)
      indexing_ = manual;
  }
};

using format_parse_context = basic_format_parse_context<char>;
using wformat_parse_context = basic_format_parse_context<wchar_t>;

template <typename Context> class basic_format_arg;
template <typename Context> class basic_format_args;
template<class T, class Char = char> struct formatter;

template <typename OutIter, typename Char>
class basic_format_context
{
  using format_args = basic_format_args<basic_format_context>;

private:
  OutIter out_;
  format_args args_;

  basic_format_context(const basic_format_context&) = delete;
  void operator=(const basic_format_context&) = delete;

public:
  using char_type = Char;
  using iterator = OutIter;
  using format_arg = basic_format_arg<basic_format_context>;
  template <typename T> using formatter_type = formatter<T,Char>;

  basic_format_context(OutIter out, format_args args)
    : out_(out), args_(args) {}

  format_arg arg(int id) const { return args_.get(id); }
  iterator out() { return out_; }
  void advance_to(iterator it) { out_ = it; }
};

namespace __format
{
  template <typename Iterator>
  inline Iterator&& reserve(Iterator&& it, size_t) { return it; }

  struct data final
  {
    static const uint64_t powers_of_10_64[];
    static const uint32_t zero_or_powers_of_10_32[];
    static const uint64_t zero_or_powers_of_10_64[];
    static const uint64_t pow10_significands[];
    static const int16_t pow10_exponents[];
    static const char digits[];
    static const char hex_digits[];
    template <typename Char> struct basic_color {
      static const Char foreground[];
      static const Char background[];
      static const Char reset[];
    };
    using color = basic_color<char>;
    using wcolor = basic_color<wchar_t>;
    data() = delete;
  };

  template <typename T> struct is_char : false_type {};
  template <> struct is_char<char> : true_type {};
  template <> struct is_char<wchar_t> : true_type {};
  template <> struct is_char<char8_t> : true_type {};
  template <> struct is_char<char16_t> : true_type {};
  template <> struct is_char<char32_t> : true_type {};

  template <typename Char>
  inline constexpr bool is_char_v = is_char<Char>::value;

  template <typename Int> using uint_32_64_t =
    conditional_t<numeric_limits<Int>::digits <= 32,
                         uint32_t, uint64_t>;

  template <typename Int> using uint_32_128_t =
    conditional_t<numeric_limits<Int>::digits <= 64,
                         uint_32_64_t<Int>, __uint128_t>;

  template <typename Int> using uint_best_fit_t = uint_32_128_t<Int>;

  template <typename T, enable_if_t<numeric_limits<T>::is_signed,int> = 0>
  inline constexpr bool is_negative(T value) { return value < 0; }

  template <typename T, enable_if_t<!numeric_limits<T>::is_signed,int> = 0>
  inline constexpr bool is_negative(T) { return false; }
  
# ifdef __has_builtin(__builtin_clz)
  // Returns the number of decimal digits in n. Leading zeros are not counted
  // except for n == 0 in which case count_digits returns 1.
  inline int count_digits(uint64_t n) {
    // Based on http://graphics.stanford.edu/~seander/bithacks.html#IntegerLog10
    // and the benchmark https://github.com/localvoid/cxx-benchmark-count-digits.
    int t = (64 - __builtin_clz(n | 1)) * 1233 >> 12;
    return t - (n < data::zero_or_powers_of_10_64[t]) + 1;
  }
# else
  // Fallback version of count_digits used when __builtin_clz is not available.
  inline int count_digits(uint64_t n) {
    int count = 1;
    for (;;) {
      // Integer division is slow so do it for a group of four digits instead
      // of for every digit. The idea comes from the talk by Alexandrescu
      // "Three Optimization Tips for C++". See speed-test for a comparison.
      if (n < 10) return count;
      if (n < 100) return count + 1;
      if (n < 1000) return count + 2;
      if (n < 10000) return count + 3;
      n /= 10000u;
      count += 4;
    }
  }
# endif

  // Counts the number of digits in n. BITS = log2(radix).
  template <unsigned BITS, typename UInt>
  inline int count_digits(UInt n) {
    int num_digits = 0;
    do {
      ++num_digits;
    } while ((n >>= BITS) != 0);
    return num_digits;
  }

  template <> int count_digits<4>(uintptr_t n);

  template <typename Spec, typename Value>
  inline void write_char(const Spec& spec, Value value) {
    auto out = spec.format_context.out();
    *out++ = static_cast<typename Spec::char_type>(value);
    spec.format_context.advance_to(out);
  }

  template <typename Spec, typename Int>
  void write_decimal(const Spec& spec, Int value) {
    using char_type = typename Spec::char_type;
    using uint_type = uint_best_fit_t<Int>;
    auto absvalue = static_cast<uint_type>(value);
    auto negative = is_negative(value);
    auto num_digits = 0;
    auto out = spec.format_context.out();
    if (negative) {
      absvalue = 0 - absvalue;
      num_digits = count_digits(absvalue);
      reserve(out, static_cast<size_t>(num_digits) + 1);
      *out++ = static_cast<char_type>('-');
    } else {
      num_digits = count_digits(absvalue);
      reserve(out, static_cast<size_t>(num_digits));
    }
    assert(num_digits >= 0 && "bad number of digits");
    enum {
          // '-' and digits
          base_size = numeric_limits<uint_type>::digits10 + 1,
          // base size and thousands separators
          buffer_size = base_size + base_size / 3,
    };
    char_type buffer[buffer_size];
    auto end = buffer + buffer_size;
    auto ptr = end;
    while (absvalue >= 100) {
      // Integer division is slow so do it for a group of two digits instead
      // of for every digit. The idea comes from the talk by Alexandrescu
      // "Three Optimization Tips for C++". See speed-test for a comparison.
      //     -- fmtlib by Victor Zverovich
      unsigned index = static_cast<unsigned>((absvalue % 100) * 2);
      absvalue /= 100;
      *--ptr = static_cast<char_type>(data::digits[index + 1]);
      //add_thousands_sep(ptr);
      *--ptr = static_cast<char_type>(data::digits[index]);
      //add_thousands_sep(ptr);
    }
    if (absvalue < 10) {
      *--ptr = static_cast<char_type>('0' + absvalue);
    } else {
      unsigned index = static_cast<unsigned>(absvalue * 2);
      *--ptr = static_cast<char_type>(data::digits[index + 1]);
      //add_thousands_sep(buffer);
      *--ptr = static_cast<char_type>(data::digits[index]);
    }
    spec.format_context.advance_to(copy(ptr, end, out));
  }

  template <typename Spec, typename Float>
  void write_floating(const Spec& spec, Float value) {
#if 0
    if (!isfinite(value)) {
      const char * const str = isinf(value) 
        ? (spec.upper ? "INF" : "inf") 
        : (spec.upper ? "NAN" : "nan");
      auto out = spec.format_context.out();
      out = copy(str, str+3, out);
      if (spec.percentage)
        *++out = static_cast<typename Spec::char_type>('%');
      spec.format_context.advance_to(out);
      return;
    }
#endif
    auto out = spec.format_context.out();
    if (spec.percentage) {
      const auto& s = to_string(value*100);
      out = copy(s.begin(), s.end(), out);
      *++out = static_cast<typename Spec::char_type>('%');
    } else {
      const auto& s = to_string(value);
      out = copy(s.begin(), s.end(), out);
    }
    spec.format_context.advance_to(out);
  }

  template<typename Char,unsigned Base>
  struct integral_prefix {
    static constexpr basic_string_view<Char> value = "";
  };
  template<> struct integral_prefix<char,2> {
    static constexpr basic_string_view<char> value = "0b";
  };
  template<> struct integral_prefix<wchar_t,2> {
    static constexpr basic_string_view<wchar_t> value = L"0b";
  };
  template<> struct integral_prefix<char,8> {
    static constexpr basic_string_view<char> value = "0";
  };
  template<> struct integral_prefix<wchar_t,8> {
    static constexpr basic_string_view<wchar_t> value = L"0";
  };
  template<> struct integral_prefix<char,16> {
    static constexpr basic_string_view<char> value = "0x";
  };
  template<> struct integral_prefix<wchar_t,16> {
    static constexpr basic_string_view<wchar_t> value = L"0x";
  };

  template<typename Char> inline Char upper_char(Char c) {
    return static_cast<Char>(toupper(c));
  }

  template<typename Char, typename Iterator>
  bool plus_sign(Iterator& out, bool negative) {
    *out++ = static_cast<Char>(negative ? '-' : '+');
    return true;
  }

  template<typename Char, typename Iterator>
  bool minus_sign(Iterator& out, bool negative) {
    if (negative) *out++ = static_cast<Char>('-');
    return negative;
  }

  template<typename Char, typename Iterator>
  bool space_sign(Iterator& out, bool negative) {
    *out++ = static_cast<Char>(negative ? '-' : ' ');
    return negative;
  }

  template<typename Char, typename Iterator>
  struct specbits {
    size_t id;
    Char fill = static_cast<Char>(' ');
    unsigned width = 0; // minimum field width
    unsigned precision = 0;
    bool (*sign)(Iterator& out, bool) = minus_sign<Char,Iterator>;
    bool hash : 1 = false;
    bool zero : 1 = false;
    bool upper : 1 = false;
    bool percentage : 1 = false;
    chars_format fmt = chars_format::general;
    virtual Iterator padding_left(Iterator out, unsigned, bool=false) const { return out; }
    virtual Iterator padding_right(Iterator out, unsigned, bool=false) const { return out; }
    virtual bool check_padding(bool) const { return false; }
  };

  template<typename ParseContext, typename FormatContext>
  struct specification {
    using parse_context_type = ParseContext;
    using format_context_type = FormatContext;
    using char_type = typename FormatContext::char_type;
    using iterator = typename FormatContext::iterator;
    using bits_t = specbits<char_type,iterator>;

    ParseContext& parse_context;
    FormatContext& format_context;

    template<unsigned Base, typename Distance>
    iterator padding_integral_prefix(const bits_t& bits, Distance& len, bool negative) const {
      auto out = format_context.out();
      auto num = bits.check_padding(true);
      auto sign = bits.sign(out, negative);
      if (sign) len += 1;
      if (bits.hash) {
        using __prefix = integral_prefix<char_type,Base>;
        auto __s = __prefix::value;
        len += __s.size();
        if (!bits.zero && !num)
          out = bits.padding_left(out, len, true);
        if (/*(Base == 16 || Base == 2) &&*/ bits.upper)
          out = transform(__s.begin(), __s.end(), out, upper_char<char_type>);
        else
          out = copy(__s.begin(), __s.end(), out);
      }
      if ((bits.zero || (num && sign)) && bits.width > len)
        out = fill_n(out, bits.width - len, static_cast<char_type>('0'));
      else if (!bits.hash)
        out = bits.padding_left(out, len, true);
      return out;
    }

    template<typename Distance>
    iterator padding_nonarith_prefix(const bits_t& bits, Distance& len) const {
      auto out = format_context.out();
      bits.check_padding(true);
      out = bits.padding_left(out, len, false);
      return out;
    }
  };

  template<typename Char, typename Iterator>
  struct default_align_bits : specbits<Char,Iterator> {
    explicit default_align_bits(unsigned id) { this->id = id; }
    Iterator padding_left(Iterator out, unsigned size, bool __on) const override {
      if (__on && /*this->width &&*/ this->width > size) {
        out = fill_n(out, this->width - size, this->fill);
      }
      return out;
    }
    Iterator padding_right(Iterator out, unsigned size, bool __on) const override {
      if (__on && /*this->width &&*/ this->width > size) {
        out = fill_n(out, this->width - size, this->fill);
      }
      return out;
    }
  };

  template<typename Char, typename Iterator>
  struct left_align_bits : specbits<Char,Iterator> {
    explicit left_align_bits(unsigned id) { this->id = id; }
    Iterator padding_right(Iterator out, unsigned size, bool) const override {
      if (/*this->width &&*/ this->width > size) {
        out = fill_n(out, this->width - size, this->fill);
      }
      return out;
    }
  };

  template<typename Char, typename Iterator>
  struct right_align_bits : specbits<Char,Iterator> {
    explicit right_align_bits(unsigned id) { this->id = id; }
    Iterator padding_left(Iterator out, unsigned size, bool) const override {
      if (/*this->width &&*/ this->width > size) {
        out = fill_n(out, this->width - size, this->fill);
      }
    }
  };

  template<typename Char, typename Iterator>
  struct numeric_align_bits : specbits<Char,Iterator> {
    explicit numeric_align_bits(unsigned id) { this->id = id; }
    Iterator padding_left(Iterator out, unsigned size, bool __on) const override {
      if (__on && /*this->width &&*/ this->width > size) {
        out = fill_n(out, this->width - size, this->fill);
      }
      return out;
    }
    bool check_padding(bool arithmetic) const override {
      if (!arithmetic) __throw_format_error("'=' with non-arithmetic type");
      return true;
    }
  };

  template<typename Char, typename Iterator>
  struct center_align_bits : specbits<Char,Iterator> {
    explicit center_align_bits(unsigned id) { this->id = id; }
    Iterator padding_left(Iterator out, unsigned size, bool) const override {
      if (/*this->width &&*/ this->width > size) {
        out = fill_n(out, (this->width - size)/2, this->fill);
      }
      return out;
    }
    Iterator padding_right(Iterator out, unsigned size, bool) const override {
      if (/*this->width &&*/ this->width > size) {
        out = fill_n(out, this->width - (this->width - size)/2, this->fill);
      }
      return out;
    }
  };

  template<typename Value, unsigned Base> struct integral_traits {
    static constexpr auto digits = numeric_limits<Value>::digits * 3 / Base + 1;
    template<typename Iterator>
    inline static auto chars(Iterator begin, Iterator end, Value value)
    { return to_chars(begin, end, value, Base); }
  };
  template<typename Value> struct integral_traits<Value,0> {
    // digits and thousands separators
    // buffer_size = __traits::digits + __traits::digits / 3,
    static constexpr auto digits = numeric_limits<Value>::digits10+1;
    template<typename Iterator>
    inline static auto chars(Iterator begin, Iterator end, Value value)
    { return to_chars(begin, end, value); }
  };

  template<typename Value, typename ParseContext, typename FormatContext, unsigned Base = 0>
  struct integral_spec : specification<ParseContext,FormatContext> {
    using typename specification<ParseContext,FormatContext>::bits_t;
    void operator()(const bits_t& bits, const Value& value) {
      using Char = typename FormatContext::char_type;
      using __traits = integral_traits<Value,Base>;
      enum { size = __traits::digits };
      Char buffer[size];
      auto res = __traits::chars(buffer, buffer+size, value);
      if (res.ec != errc(0))
        __throw_format_error("format integer value error");
      else {
        auto len = distance(buffer, res.ptr);
        auto out = this->template padding_integral_prefix<Base>(bits, len, value < 0);
        if (Base == 16 && bits.upper)
          out = transform(buffer, res.ptr, out, upper_char<Char>);
        else
          out = copy(buffer, res.ptr, out);
        if (!bits.zero)
          out = bits.padding_right(out, len, false);
        this->format_context.advance_to(out);
      }
    }
  };

  template<typename Char = char> struct bool_sv {
    auto __sv(bool value) const {
      return value
        ? basic_string_view<char>("true",4)
        : basic_string_view<char>("false",5);
    }
  };
  template<> struct bool_sv<wchar_t> {
    auto __sv(bool value) const {
      return value
        ? basic_string_view<wchar_t>(L"true",4)
        : basic_string_view<wchar_t>(L"false",5);
    }
  };
  template<typename ParseContext, typename FormatContext, unsigned Base>
  struct bool_spec : specification<ParseContext,FormatContext> {
    using typename specification<ParseContext,FormatContext>::bits_t;
    using Char = typename FormatContext::char_type;
    void operator()(const bits_t& bits, bool value) {
      unsigned len = 1;
      auto out = this->template padding_integral_prefix<Base>(bits, len, false);
      *out++ = static_cast<Char>(value ? '1' : '0');
      out = bits.padding_right(out, len);
      this->format_context.advance_to(out);
    }
  };
  template<typename ParseContext, typename FormatContext>
  struct bool_spec<ParseContext,FormatContext,0>
    : specification<ParseContext,FormatContext>
    , bool_sv<typename FormatContext::char_type> 
  {
    using typename specification<ParseContext,FormatContext>::bits_t;
    void operator()(const bits_t& bits, bool value) {
      auto __s = this->__sv(value);
      auto len = __s.size();
      auto out = this->padding_nonarith_prefix(bits, len);
      out = copy(__s.begin(), __s.end(), out);
      out = bits.padding_right(out, len, true);
      this->format_context.advance_to(out);
    }
  };
  template<typename ParseContext, typename FormatContext, unsigned Base>
  struct integral_spec<bool,ParseContext,FormatContext,Base>
    : bool_spec<ParseContext,FormatContext,Base> {};

  template<typename ParseContext, typename FormatContext, typename Value>
  struct char_spec : specification<ParseContext,FormatContext> {
    using typename specification<ParseContext,FormatContext>::bits_t;
    using Char = typename FormatContext::char_type;
    inline void operator()(const bits_t& bits, Value value) {
      unsigned len = 1;
      auto out = this->padding_nonarith_prefix(bits, len);
      *out++ = static_cast<Char>(value); // FIXME: unicode charconv
      out = bits.padding_right(out, len, true);
      this->format_context.advance_to(out);
    }
  };
  template<typename ParseContext, typename FormatContext>
  struct integral_spec<char,ParseContext,FormatContext,0>
    : char_spec<ParseContext,FormatContext,char> {};
  template<typename ParseContext, typename FormatContext>
  struct integral_spec<wchar_t,ParseContext,FormatContext,0>
    : char_spec<ParseContext,FormatContext,wchar_t> {};

  template<typename Value, typename ParseContext, typename FormatContext>
  struct floating_spec : specification<ParseContext,FormatContext> {
    using typename specification<ParseContext,FormatContext>::bits_t;
    void operator()(const bits_t& bits, const Value& value) {
      // TODO: deal with precision, etc....
      // TODO: extend and using to_chars instead
      auto out = this->format_context.out();
      if (bits.percentage) {
        using char_type = typename FormatContext::char_type;
        const auto& s = to_string(value*100);
        out = copy(s.begin(), s.end(), out);
        *out++ = static_cast<char_type>('%');
      } else {
        const auto& s = to_string(value);
        out = copy(s.begin(), s.end(), out);
      }
      this->format_context.advance_to(out);
    }
  };

  template<typename ParseContext, typename FormatContext>
  struct default_spec : specification<ParseContext,FormatContext> {
    using typename specification<ParseContext,FormatContext>::bits_t;
    void operator()(const bits_t& bits, const char* value) {
      this->operator()(bits, basic_string_view<char>(value));
    }
    void operator()(const bits_t& bits, const wchar_t* value) {
      this->operator()(bits, basic_string_view<wchar_t>(value));
    }
    template<typename Char>
    void operator()(const bits_t& bits, const basic_string<Char>& __s) {
      this->copy_str(bits, __s.begin(), __s.end());
    }
    template<typename Char>
    void operator()(const bits_t& bits, basic_string_view<Char> __s) {
      this->copy_str(bits, __s.begin(), __s.end());
    }

    template<typename Value>
    void operator()(const bits_t& bits, const Value& value) {
      __throw_format_error("default specification for unexpected value");
    }

  private:
    template<typename Iterator>
    void copy_str(const bits_t& bits, Iterator begin, Iterator end) const {
      auto len = distance(begin, end);
      auto out = this->padding_nonarith_prefix(bits, len);
      out = bits.padding_right(copy(begin, end, out), len, true);
      this->format_context.advance_to(out);
    }
  };

  template<typename ParseContext, typename FormatContext>
  struct pointer_spec : specification<ParseContext,FormatContext> {
    using typename specification<ParseContext,FormatContext>::bits_t;
    template<typename T>
    void operator()(const bits_t& bits, const T* value) {
      using __traits = integral_traits<uintptr_t,16>;
      using char_type = typename FormatContext::char_type;
      enum { size = __traits::digits };
      char_type buffer[size];
      auto __v = reinterpret_cast<uintptr_t>(value);
      auto res = __traits::chars(buffer, buffer+size, __v);
      if (res.ec != errc(0))
        __throw_format_error("format integer value error");
      else {
        auto out = this->format_context.out();
        *out++ = static_cast<char_type>('0');
        *out++ = static_cast<char_type>('x'); // FIXME: upper 'X'
        out = copy(buffer, res.ptr, out);
        this->format_context.advance_to(out);
      }
    }
  };

  template<typename ParseContext, typename FormatContext>
  struct unmatched_type_spec : specification<ParseContext,FormatContext> {
    using typename specification<ParseContext,FormatContext>::bits_t;
    template<typename Value>
    void operator()(const bits_t& bits, const Value& value) {
      __throw_format_error("format value of unmatched type");
    }
  };

  template <typename Char, typename OutIter> class driver final {
    using ParseContext = basic_format_parse_context<Char>;
    using FormatContext = basic_format_context<OutIter,Char>;
    using InputIter = typename ParseContext::iterator;
    using bits_t = specbits<Char,OutIter>;

    ParseContext parse_context;
    FormatContext format_context;

    static_assert(is_same<OutIter,typename FormatContext::iterator>());

    void chars(InputIter& pos, const InputIter end) {
      auto out = copy(pos, end, format_context.out());
      format_context.advance_to(out);
    }

    void escape(Char character) {
      auto out = format_context.out();
      *out = character;
      ++out;
      format_context.advance_to(out);
    }

    int positive_int(InputIter& pos, const InputIter end) {
      assert(pos != end && '0' <= *pos && *pos <= '9');
      if (*pos == '0') {
        ++pos;
        return 0;
      }
      unsigned val = 0;
      unsigned max = std::numeric_limits<int>::max();
      unsigned top = max / 10;
      do {
        val = val * 10 + unsigned(*pos - '0');
        ++pos;
        if (val > top) { // overflow
          val = top + 1;
          break;
        }
      } while (pos != end && '0' <= *pos && *pos <= '9');
      return static_cast<int>(val);
    }

    auto arg_id(InputIter& pos, const InputIter end) {
      size_t id;
      auto c = *pos;
      if ('0' <= c && c <= '9') {
        id = this->positive_int(pos, end);
        parse_context.check_arg_id(id);
      } else {
        id = parse_context.next_arg_id();
      }
      return id;
    }

    void replacement(InputIter& pos, const InputIter end) {
      assert(*pos == '{' && "unexpected replacement openning");
      ++pos;
      if (pos == end) {
        __throw_format_error("malform format string");
      }
      const auto id = this->arg_id(pos, end);
      if (pos == end) {
        __throw_format_error("malform format string");
      } else if (*pos == ':') {
        ++pos;
        this->spec_align(id, pos, end);
      } else if (*pos == '}') {
        ++pos;
        this->handle_arg(default_align_bits<Char,OutIter>{ id });
      } else {
        __throw_format_error("malform format replacement");
      }
    }

    void spec_align(size_t id, InputIter& pos, const InputIter end) {
      if (pos == end) {
        __throw_format_error("malform format replacement spec");
      } else if (*pos == '}') {
        ++pos;
        this->handle_arg(default_align_bits<Char,OutIter>{ id });
        return;
      } else if (auto next = pos + 1; next != end) {
        switch (*next) {
        case '<': {
          left_align_bits<Char,OutIter> bits{ id };
          if ((bits.fill = *pos) == '{')
            __throw_format_error("invalid fill character '{'");
          pos += 2;
          this->spec_sign(bits, pos, end);
        } break;
        case '>': {
          right_align_bits<Char,OutIter> bits{ id };
          if ((bits.fill = *pos) == '{')
            __throw_format_error("invalid fill character '{'");
          pos += 2;
          this->spec_sign(bits, pos, end);
        } break;
        case '=': {
          numeric_align_bits<Char,OutIter> bits{ id };
          if ((bits.fill = *pos) == '{')
            __throw_format_error("invalid fill character '{'");
          pos += 2;
          this->spec_sign(bits, pos, end);
        } break;
        case '^': {
          center_align_bits<Char,OutIter> bits{ id };
          if ((bits.fill = *pos) == '{')
            __throw_format_error("invalid fill character '{'");
          pos += 2;
          this->spec_sign(bits, pos, end);
        } break;
        default:
          switch (*pos) {
          case '<': {
            left_align_bits<Char,OutIter> bits{ id };
            pos = next;
            this->spec_sign(bits, pos, end);
          } break;
          case '>': {
            right_align_bits<Char,OutIter> bits{ id };
            pos = next;
            this->spec_sign(bits, pos, end);
          } break;
          case '=': {
            numeric_align_bits<Char,OutIter> bits{ id };
            pos = next;
            this->spec_sign(bits, pos, end);
          } break;
          case '^': {
            center_align_bits<Char,OutIter> bits{ id };
            pos = next;
            this->spec_sign(bits, pos, end);
          } break;
          default: {
            default_align_bits<Char,OutIter> bits{ id };
            this->spec_sign(bits, pos, end);
          } break;
          }
        }
      } else {
        __throw_format_error("malform format spec");
      }
    }

    void spec_sign(bits_t& bits, InputIter& pos, const InputIter end) {
      if (pos == end)
        __throw_format_error("malform format spec");
      switch (*pos) {
      case '+':
        bits.sign = plus_sign<Char,OutIter>;
        ++pos;
        break;
      case '-':
        bits.sign = minus_sign<Char,OutIter>;
        ++pos;
        break;
      case ' ':
        bits.sign = space_sign<Char,OutIter>;
        ++pos;
        break;
      }
      this->spec_alt(bits, pos, end);
    }

    void spec_alt(bits_t& bits, InputIter& pos, const InputIter end) {
      if (pos == end) {
        __throw_format_error("malform format replacement spec");
      } else if (*pos == '#') {
        bits.hash = true;
        ++pos;
      }
      this->spec_width(bits, pos, end);
    }

    void spec_width(bits_t& bits, InputIter& pos, const InputIter end) {
      if (pos == end) {
        __throw_format_error("malform format replacement spec");
      } else if (*pos == '0') {
        bits.zero = true;
        ++pos;
      }
      if (pos == end) {
        __throw_format_error("malform format replacement spec");
      } else if ('1' <= *pos && *pos <= '9') {
        bits.width = positive_int(pos, end);
      }
      if (pos != end && *pos == '.') {
        if (++pos == end) {
          __throw_format_error("malform format replacement spec");
        } else {
          bits.precision = positive_int(pos, end);
        }
      }
      this->spec_type(bits, pos, end);
    }

    void spec_type(bits_t& bits, InputIter& pos, const InputIter end) {
      if (pos == end)
        __throw_format_error("malform format replacement spec");
      const auto type = *pos++;
      if (type == '}') {
        this->handle_arg(bits);
        return;
      }
      if (*pos != '}') {
        __throw_format_error("malform format replacement spec");
      } else {
        ++pos;
        switch (type) { // presentation type
        case 'a':
          bits.fmt = chars_format::hex;
          this->handle_floating(bits);
          break;
        case 'A':
          bits.fmt = chars_format::hex;
          bits.upper = true;
          this->handle_floating(bits);
          break;
        case 'b':
          this->handle_integral<2>(bits);
          break;
        case 'B':
          bits.upper = true;
          this->handle_integral<2>(bits);
          break;
        case 'c':
          this->handle_character(bits);
          break;
        case 'd':
          this->handle_integral<10>(bits);
          break;
        case 'e':
          bits.fmt = chars_format::scientific;
          if (bits.precision == 0) bits.precision = 6;
          this->handle_floating(bits);
          break;
        case 'E':
          bits.fmt = chars_format::scientific;
          bits.upper = true;
          if (bits.precision == 0) bits.precision = 6;
          this->handle_floating(bits);
          break;
        case 'f':
          bits.fmt = chars_format::fixed;
          if (bits.precision == 0) bits.precision = 6;
          this->handle_floating(bits);
          break;
        case 'F':
          bits.fmt = chars_format::fixed;
          bits.upper = true;
          if (bits.precision == 0) bits.precision = 6;
          this->handle_floating(bits);
          break;
        case 'g':
          bits.fmt = chars_format::general;
          if (bits.precision == 0) bits.precision = 6;
          this->handle_floating(bits);
          break;
        case 'G':
          bits.fmt = chars_format::general;
          bits.upper = true;
          if (bits.precision == 0) bits.precision = 6;
          this->handle_floating(bits);
          break;
        case 'n':
          this->handle_numeric(bits);
          break;
        case 'o':
          this->handle_integral<8>(bits);
          break;
        case 'p':
          this->handle_pointer(bits);
          break;
        case 's':
          this->handle_string(bits);
          break;
        case 'x':
          this->handle_integral<16>(bits);
          break;
        case 'X':
          bits.upper = true;
          this->handle_integral<16>(bits);
          break;
        case '%':
          // TODO: floating point as percentage
          break;
        }
      }
    }

    void handle_arg(const specbits<Char,OutIter>& bits) {
      visit_format_arg([this, &bits](const auto &value){
        using Value = remove_cvref_t<decltype(value)>;
        conditional_t<is_floating_point_v<Value>,floating_spec<Value,ParseContext,FormatContext>,
                      conditional_t<is_integral_v<Value>,integral_spec<Value,ParseContext,FormatContext>,
                                    default_spec<ParseContext,FormatContext>>>
          spec{ parse_context, format_context };
        spec(bits, value);
      }, format_context.arg(bits.id));
    }

    void handle_floating(const specbits<Char,OutIter>& bits) {
      visit_format_arg([this, &bits](const auto &value){
        using Value = remove_cvref_t<decltype(value)>;
        conditional_t<is_floating_point_v<Value>,floating_spec<Value,ParseContext,FormatContext>,
                      unmatched_type_spec<ParseContext,FormatContext>>
          spec{ parse_context, format_context };
        spec(bits, value);
      }, format_context.arg(bits.id));
    }

    template <unsigned Base>
    void handle_integral(const specbits<Char,OutIter>& bits) {
      visit_format_arg([this, &bits](const auto &value){
        using Value = remove_cvref_t<decltype(value)>;
        conditional_t<is_integral_v<Value>,integral_spec<Value,ParseContext,FormatContext,Base>,
                      unmatched_type_spec<ParseContext,FormatContext>>
          spec{ parse_context, format_context };
        spec(bits, value);
      }, format_context.arg(bits.id));
    }

    void handle_numeric(const specbits<Char,OutIter>& bits) {
      visit_format_arg([this, &bits](const auto &value){
        using Value = remove_cvref_t<decltype(value)>;
        conditional_t<is_floating_point_v<Value>,floating_spec<Value,ParseContext,FormatContext>,
                      conditional_t<is_integral_v<Value>,integral_spec<Value,ParseContext,FormatContext,10>,
                                    unmatched_type_spec<ParseContext,FormatContext>>>
          spec{ parse_context, format_context };
        spec(bits, value);
      }, format_context.arg(bits.id));
    }

    void handle_character(const specbits<Char,OutIter>& bits) {
      visit_format_arg([this, &bits](const auto &value){
        using Value = remove_cvref_t<decltype(value)>;
        conditional_t<is_char_v<Value>,integral_spec<Value,ParseContext,FormatContext,0>,
                      unmatched_type_spec<ParseContext,FormatContext>>
          spec{ parse_context, format_context };
        spec(bits, value);
      }, format_context.arg(bits.id));
    }

    void handle_pointer(const specbits<Char,OutIter>& bits) {
      visit_format_arg([this, &bits](const auto &value){
        using Value = remove_cvref_t<decltype(value)>;
        conditional_t<is_pointer_v<Value>,pointer_spec<ParseContext,FormatContext>,
                      unmatched_type_spec<ParseContext,FormatContext>>
          spec{ parse_context, format_context };
        spec(bits, value);
      }, format_context.arg(bits.id));
    }

    void handle_string(const specbits<Char,OutIter>& bits) {
      visit_format_arg([this, &bits](const auto &value){
        using Value = remove_cvref_t<decltype(value)>;
        conditional_t<is_char_v<Value>,default_spec<ParseContext,FormatContext>,
                      unmatched_type_spec<ParseContext,FormatContext>>
          spec{ parse_context, format_context };
        spec(bits, value);
      }, format_context.arg(bits.id));
    }

  public:
    template <typename S, typename FormatArgs>
    constexpr driver(const S& fmt, OutIter out, FormatArgs args)
      : parse_context(fmt), format_context(out, args) {}
    constexpr OutIter operator()() {
      auto const end = parse_context.end();
      auto pos = parse_context.begin();
      auto last = pos;
      while (pos != end) {
        switch (*pos) {
        case '{': {
          if (last < pos) this->chars(last, pos);
          auto next = pos + 1;
          if (next == end) {
            // finish
          } else if (*next == '{') {
            ++next;
            this->escape(*pos);
            pos = next;
          } else {
            this->replacement(pos, end);
          }
          last = pos;
        } break;
        case '}': { // unbalanced close brace
          if (last < pos) this->chars(last, pos);
          auto next = pos + 1;
          if (next == end) {
            pos = end; // finish
          } else if (*next == '}') {
            ++next;
            this->escape(*pos);
            last = pos = next;
          } else {
            this->chars(pos, next);
            last = pos = end;
          }
        } break;
        default: ++pos;
        }
      }
      if (last < pos) this->chars(last, pos);
      parse_context.advance_to(pos);
      return format_context.out();
    }
  };

  template <typename Char>
  class basic_string_inserter
    : public back_insert_iterator<basic_string<Char>>
  {
  public:
    explicit basic_string_inserter(basic_string<Char>& __x)
      : back_insert_iterator<basic_string<Char>>(__x) {}
    void reserve(size_t size) { this->container->reserve(size); }
  };

  template <typename Char>
  using basic_string_format_context = basic_format_context<basic_string_inserter<Char>,Char>;
} // __format

using format_context = __format::basic_string_format_context<char>;
using wformat_context = __format::basic_string_format_context<wchar_t>;

template<class T, class Char> struct formatter
{
  // T is unsupported by standard formatter, you have to specialize
  // std::formatter<T,Char> in your code.
  formatter() = delete;
};

namespace __format
{
  // selecting smaller type

  template <typename T, typename... Types> struct smaller;
  template <typename T, typename Type>
  struct smaller<T,Type> { using type = Type; };

  template <typename T, typename Type, typename... Rest>
  struct smaller<T,Type,Rest...> : conditional_t<(sizeof(T)<=sizeof(Type)),
    smaller<T,Type>, smaller<T,Rest...>> {};

  template <typename T, typename... Types>
  using smaller_t = typename smaller<T,Types...>::type;

# if 0
  template <typename T, bool = is_integral_v<T>> struct integer
  {
    using Int = conditional_t<
      is_unsigned_v<T>,
      smaller_t<T,unsigned int,unsigned long long int>,
      smaller_t<T,int,long long int>>;
    Int val(const T& v) noexcept { return static_cast<Int>(v); }
  };
# endif

  // integer

  template <typename T, bool = is_unsigned_v<T>>
  struct fit_integer
  {
    using type = smaller_t<T,unsigned int,unsigned long long int>;
  };
  template <typename T> struct fit_integer<T,false>
  {
    using type = smaller_t<T,int,long long int>;
  };
} // __format

template<class Context, class... Args> struct format_arg_store;

template<class Context> class basic_format_arg {
public:
  class handle;

private:
  using char_type = typename Context::char_type;

  variant<
    monostate, bool, char_type, int, unsigned int,
    long long int, unsigned long long int, double, long double,
    const char_type*, basic_string_view<char_type>,
    const void*, handle> var;

  template<class X, class... Args>
  friend struct format_arg_store;

  // integer

  template <typename T, bool = is_integral_v<T>>
  struct integer : __format::fit_integer<T>
  {
    using typename __format::fit_integer<T>::type;
    type val(const T& v) const noexcept { return static_cast<type>(v); }
  };

  template <typename T> struct integer<T,false> {
    handle val(const T& v) const noexcept { return handle(v); }
  };

  template <typename T> struct identical {
    T val(T v) const noexcept { return v; }
  };

  template <typename T> struct best_store : integer<T> {};
  template <> struct best_store<bool> : identical<bool> {};
  template <> struct best_store<char> : identical<char> {};
  template <> struct best_store<wchar_t> : identical<wchar_t> {};
  template <> struct best_store<char8_t> : identical<char8_t> {};
  template <> struct best_store<char16_t> : identical<char16_t> {};
  template <> struct best_store<char32_t> : identical<char32_t> {};

  template<class T> explicit basic_format_arg(const T& v) noexcept
    : var(best_store<T>().val(v)) {}

  explicit basic_format_arg(float n) noexcept : var(static_cast<double>(n)) {}
  explicit basic_format_arg(double n) noexcept : var(n) {}
  explicit basic_format_arg(long double n) noexcept : var(n) {}
  explicit basic_format_arg(const char_type* s) : var(s) {}

  template<class Traits>
  explicit basic_format_arg(basic_string_view<char_type,Traits> s) noexcept
    : var(s) {}

  template<class Traits, class Allocator>
  explicit basic_format_arg(const basic_string<char_type,Traits,Allocator>& s) noexcept
    : basic_format_arg(basic_string_view(s.data(), s.size())) {}

  explicit basic_format_arg(nullptr_t) noexcept
    : var(static_cast<const void*>(nullptr)) {}

  explicit basic_format_arg(const void* p) noexcept
    : var(p) {}

  template<class Visitor, class Ctx>
  friend auto visit_format_arg(Visitor&& visit, basic_format_arg<Ctx> arg)
    -> decltype(visit(0));

  template<class Ctx, class... Args>
  friend format_arg_store<Ctx, Args...> make_format_args(const Args&... args);

public:
  basic_format_arg() noexcept {}
  explicit operator bool() const noexcept {
    return !holds_alternative<monostate>(var);
  }
};

template<class Context>
class basic_format_arg<Context>::handle {
  friend class basic_format_arg<Context>;

  using char_type = typename Context::char_type;
  using parse_context = basic_format_parse_context<char_type>;

  template<typename T>
  using formatter = typename Context::template formatter_type<T>;

  const void* ptr;
  void (*fmt)(parse_context&, Context&, const void*);

  template<class T> explicit handle(const T& val) noexcept
    : ptr(&val)
    , fmt([](parse_context& parse_ctx, Context& format_ctx, const void* ptr) {
        formatter<T> __f;
        auto& val = *static_cast<const T*>(ptr);
        parse_ctx.advance_to(__f.parse(parse_ctx));
        format_ctx.advance_to(__f.format(val, format_ctx));
      })
  {}

public:
  void format(parse_context& parse_ctx, Context& format_ctx) const
  { fmt(parse_ctx, format_ctx, ptr); }
};

namespace __format
{
#if 0
  template<typename T> struct handle<basic_format_arg<T>> {
    template<typename Spec>
    void format(const Spec& spec, basic_format_arg<T> arg) const {
      visit_format_arg([this, &spec](const auto& val){
        using val_type = remove_cvref_t<decltype(val)>;
        handle<val_type>().format(spec, val);
      }, arg);
    }
  };
#endif
#if __has_feature(ASSOCIATED_TYPENAME_SPECIALIZATION)
  template<typename FormatContext>
  struct handle<typename basic_format_arg<FormatContext>::handle> {
    template<typename ParseContext>
    void format(const Spec& spec, typename basic_format_arg<FormatContext>::handle h) const {
      h.format(spec);
    }
  };
#endif // ASSOCIATED_TYPENAME_SPECIALIZATION
}

#if false

namespace __format
{
  template<class Ret, class Visitor, typename... Types> struct visit_by_type;
  template<class Ret, class Visitor> struct visit_by_type<Ret, Visitor>
  {
    template<class Ctx>
    Ret apply(Visitor&& visit, basic_format_arg<Ctx> arg)
    { return visit(monostate()); }
  };

  template<class Ret, class Visitor, typename T, typename... Rest>
  struct visit_by_type<Ret, Visitor, T, Rest...>
  {
    template<class Ctx>
    Ret apply(Visitor&& visit, basic_format_arg<Ctx> arg)
    {
      if (arg.type == &typeid(T))
        return visit(*reinterpret_cast<T*>(&arg.int_value));
      else
        return visit_by_type<Ret,Visitor,Rest...>().apply(visit, arg);
    }
  };
} // __format

template<class Visitor, class Ctx> inline auto
visit_format_arg(Visitor&& visitor, basic_format_arg<Ctx> arg)
  -> decltype(visitor(0))
{
  using handle = typename basic_format_arg<Ctx>::handle;
  using char_type = typename basic_format_arg<Ctx>::char_type;
  __format::visit_by_type
    <decltype(visitor(0)), Visitor,
     monostate, bool, char_type, int, unsigned int,
     long long int, unsigned long long int, double, long double,
     const char_type*, basic_string_view<char_type>,
     const void*, handle> by_type;
  return by_type.apply(move(visitor), arg);
}

#else

template<class Visitor, class Ctx> inline auto
visit_format_arg(Visitor&& visitor, basic_format_arg<Ctx> arg)
  -> decltype(visitor(0))
{ return visit(move(visitor), arg.var); }

#endif

namespace __format
{
  template <typename Char> inline basic_string_inserter<Char>&&
  reserve(basic_string_inserter<Char>&& it, size_t size) {
    it.reserve(size);
    return move(it);
  }

  inline char8_t to_char8_t(char c) { return static_cast<char8_t>(c); }

  template <typename InputIt, typename OutChar>
  constexpr const bool needs_conversion = bool_constant<
    is_same<typename iterator_traits<InputIt>::value_type, char>::value &&
    is_same<OutChar, char8_t>::value>::value;

  template <typename OutChar, typename InputIt, typename OutputIt,
            enable_if_t<!needs_conversion<InputIt,OutChar>,int> = 0>
  OutputIt copy_str(InputIt begin, InputIt end, OutputIt it) {
    return copy(begin, end, it);
  }

  template <typename OutChar, typename InputIt, typename OutputIt,
            enable_if_t<needs_conversion<InputIt,OutChar>,int> = 0>
  OutputIt copy_str(InputIt begin, InputIt end, OutputIt it) {
    return transform(begin, end, it, to_char8_t);
  }

} // __format

template<class Context, class... Args>
struct format_arg_store {
  array<basic_format_arg<Context>,sizeof...(Args)> args;
  format_arg_store(const Args&... args)
    : args{ basic_format_arg<Context>(args)... } {}
};

template<class Context = format_context, class... Args>
inline format_arg_store<Context,Args...>
make_format_args(const Args&... args) { return {args...}; }

template<class... Args>
inline format_arg_store<wformat_context,Args...>
make_wformat_args(const Args&... args) { return {args...}; }

template<class Context> class basic_format_args {
  const basic_format_arg<Context>* args;
  size_t num_args;

public:
  basic_format_args() noexcept;

  template<class... Args>
  basic_format_args(const format_arg_store<Context,Args...>& store) noexcept
    : args(store.args.data()), num_args(store.args.size()) {}

  basic_format_arg<Context> get(size_t i) const noexcept
  { return i < num_args ? args[i] : basic_format_arg<Context>(); }
};

#if 0
template<typename T,typename Char>
struct formatter<T,Char>
{
  template <typename FormatContext>
  constexpr typename FormatContext::iterator
  format(FormatContext& context) {
    auto specifier = this->parsed_specifier();
    if (specifier) specifier->write(context, 0);
    return context.out();
  }
};
#endif

namespace __format
{
  template<typename Char>
  using basic_string_format_args = basic_format_args<basic_string_format_context<Char>>;

  void as_string_view(...);

  template<typename Char, enable_if<is_char_v<Char>>>
  inline basic_string_view<Char>
  as_string_view(const Char* s) { return {s}; }

  template<typename Char, typename Traits, typename Allocator>
  inline basic_string_view<Char>
  as_string_view(const basic_string<Char,Traits,Allocator>& s)
  { return {s.data(), s.size()}; }

  template<typename Char, typename Traits>
  inline basic_string_view<Char>
  as_string_view(basic_string_view<Char,Traits> s)
  { return {s.data(), s.size()}; }

  template <typename S>
  struct is_string : is_class<decltype(as_string_view(declval<S>()))> {};

  template <> struct is_string<void> : false_type {};

  template<typename S>
  inline constexpr bool is_string_v = is_string<S>::value;

  template<typename S, typename=void> struct associated_char {};
  template<typename S> struct associated_char<S,enable_if_t<is_string_v<S>>> {
    using string_view = decltype(as_string_view(declval<S>()));
    using type = typename string_view::value_type;
  };

  template <typename S>
  using char_t = typename associated_char<S>::type;
} // __format

using format_args = __format::basic_string_format_args<char>;
using wformat_args = __format::basic_string_format_args<wchar_t>;

template<typename Out, typename Char>
using format_args_t = basic_format_args<basic_format_context<Out,Char>>;

template <typename Out, typename S, typename Char = __format::char_t<S>>
inline Out vformat_to(Out out, const S& fmt, format_args_t<Out,Char> args) {
  return __format::driver<Char,Out>(fmt, out, args)();
}

template<class S, class Context, typename Char = __format::char_t<S>>
inline auto vformat(const S& fmt, basic_format_args<Context> args) {
  basic_string<Char> buffer;
  __format::basic_string_inserter<Char> out(buffer);
  vformat_to(out, fmt, args);
  return buffer;
}

template<typename S, typename... Args, typename Char = __format::char_t<S>>
inline auto format(const S& fmt, const Args&... args) {
  using Context = __format::basic_string_format_context<Char>;
  auto store = make_format_args<Context>(args...);
  const basic_format_args<Context> va(store);
  return vformat(fmt, va);
}

template<typename Char, int N, class... Args>
inline auto format(const Char fmt[N], const Args&... args) {
# if 0
  return format(__format::as_string_view(fmt), args...);
# else
  return format(basic_string_view<Char>(fmt,N), args...);
# endif
}

template<typename Char, class... Args>
inline auto format(const Char* fmt, const Args&... args) {
# if 0
  return format(__format::as_string_view(fmt), args...);
# else
  return format(basic_string_view<Char>(fmt), args...);
# endif
}

_LIBCPP_END_NAMESPACE_STD
