// -*- C++ -*-
//===--------------------------- format -----------------------------------===//
//
//    Copyright (c) 2018-2019 Duzy Chan at ExtBit Limited.
//    This file is part of ExtC++, the ExtBit C++ standard library.
//
//    <format> implements jtc1/sc22/wg21/docs/papers/2019/p0645r9,
//    insipred by the fmtlib by Victor Zverovich.
//
//===----------------------------------------------------------------------===//
#pragma once
#pragma GCC system_header
#if defined(format_synopsis)
namespace std {
  // [format.error], class format_error
  class format_error;

  // [format.formatter], formatter
  template<class Char> class basic_format_parse_context;
  using format_parse_context = basic_format_parse_context<char>;
  using wformat_parse_context = basic_format_parse_context<wchar_t>;
  
  template<class Out, class Char> class basic_format_context;
  using format_context = basic_format_context<unspecified, char>;
  using wformat_context = basic_format_context<unspecified, wchar_t>;

  template<class T, class Char = char> struct formatter;
  
  // [format.arguments], arguments
  template<class Context> class basic_format_arg;

  template<class Visitor, class Context>
    see_below visit_format_arg(Visitor&& vis, basic_format_arg<Context> arg);

  template<class Context, class... Args> struct format_arg_store; // exposition only

  template<class Context> class basic_format_args;
  using format_args = basic_format_args<format_context>;
  using wformat_args = basic_format_args<wformat_context>;

  template<class Out, class Char>
    using format_args_t = basic_format_args<basic_format_context<Out, Char>>;

  template<class Context = format_context, class... Args>
    format_arg_store<Context, Args...>
      make_format_args(const Args&... args);
  template<class... Args>
    format_arg_store<wformat_context, Args...>
      make_wformat_args(const Args&... args);

  // [format.functions], formatting functions
  template<class... Args>
    string format(string_view fmt, const Args&... args);
  template<class... Args>
    wstring format(wstring_view fmt, const Args&... args);

  string vformat(string_view fmt, format_args args);
  wstring vformat(wstring_view fmt, wformat_args args);

  template<class Out, class... Args>
    Out format_to(Out out, string_view fmt, const Args&... args);
  template<class Out, class... Args>
    Out format_to(Out out, wstring_view fmt, const Args&... args);

  template<class Out>
    Out vformat_to(Out out, string_view fmt, format_args_t<Out, char> args);
  template<class Out>
    Out vformat_to(Out out, wstring_view fmt, format_args_t<Out, wchar_t> args);

  template<class Out>
    struct format_to_n_result {
      Out out;
      iter_difference_t<Out> size;
    };
  
  template<class Out, class... Args>
    format_to_n_result<Out> format_to_n(Out out, iter_difference_t<Out> n,
                                        string_view fmt, const Args&... args);
  template<class Out, class... Args>
    format_to_n_result<Out> format_to_n(Out out, iter_difference_t<Out> n,
                                        wstring_view fmt, const Args&... args);

  template<class... Args>
    size_t formatted_size(string_view fmt, const Args&... args);
  template<class... Args>
    size_t formatted_size(wstring_view fmt, const Args&... args);
}
#endif

#include <__config>
#include <charconv>
#include <stdexcept>
#include <string_view>
#include <string>
#include <stdint.h>
#include <variant>
#include <array>
#include <iostream>

_LIBCPP_BEGIN_NAMESPACE_STD

class format_error : public runtime_error
{
public:
  explicit format_error(const string& message) : runtime_error(message) {}
  explicit format_error(const char* message) : runtime_error(message) {}
};

[[noreturn]] inline _LIBCPP_INLINE_VISIBILITY
void __throw_format_error(const char*__msg)
{
#ifndef _LIBCPP_NO_EXCEPTIONS
    throw format_error(__msg);
#else
    ((void)__msg);
    _VSTD::abort();
#endif
}

template <typename Char>
class basic_format_parse_context {
  basic_string_view<Char> fmt_;
  enum { unknown, manual, automatic } indexing_;
  _VSTD::size_t next_arg_id_;
  _VSTD::size_t num_args_;

  basic_format_parse_context(const basic_format_parse_context&) = delete;
  basic_format_parse_context& operator=(const basic_format_parse_context&) = delete;

public:
  using char_type = Char;
  using const_iterator = typename basic_string_view<Char>::const_iterator;
  using iterator = const_iterator;

  explicit constexpr basic_format_parse_context(basic_string_view<Char> fmt, size_t num_args = 0) noexcept
    : fmt_(fmt), indexing_(unknown), next_arg_id_(0), num_args_(num_args) {}

  constexpr const_iterator begin() const noexcept { return fmt_.begin(); }
  constexpr const_iterator end() const noexcept { return fmt_.end(); }
  constexpr void advance_to(const_iterator it) {
    // Expects: end() is reachable from it.
    // static_cast<make_unsigned_t<?>>(it - begin());
    fmt_.remove_prefix(static_cast<size_t>(it - begin()));
  }

  constexpr int next_arg_id() {
    if (indexing_ == manual)
      __throw_format_error("mixing of automatic and manual argument indexing");
    else if (indexing_ == unknown)
      indexing_ = automatic;
    return next_arg_id_++;
  }

  constexpr void check_arg_id(size_t id) {
    // Expects: next_arg_id_ < num_args_
    if (indexing_ == automatic)
      __throw_format_error("mixing of automatic and manual argument indexing");
    else if (indexing_ == unknown)
      indexing_ = manual;
  }
};

using format_parse_context = basic_format_parse_context<char>;
using wformat_parse_context = basic_format_parse_context<wchar_t>;

template <typename Context> class basic_format_arg;
template <typename Context> class basic_format_args;
template<class T, class Char = char> struct formatter;

template <typename OutIter, typename Char>
class basic_format_context
{
  using format_args = basic_format_args<basic_format_context>;

private:
  OutIter out_;
  format_args args_;

  basic_format_context(const basic_format_context&) = delete;
  void operator=(const basic_format_context&) = delete;

public:
  using char_type = Char;
  using iterator = OutIter;
  using format_arg = basic_format_arg<basic_format_context>;
  template <typename T> using formatter_type = formatter<T,Char>;

  basic_format_context(OutIter out, format_args args)
    : out_(out), args_(args) {}

  format_arg arg(int id) const { return args_.get(id); }
  iterator out() { return out_; }
  void advance_to(iterator it) { out_ = it; }
};

namespace __format
{
  template <typename Iterator>
  inline Iterator&& reserve(Iterator&& it, _VSTD::size_t) { return it; }

  struct data final
  {
    static const uint64_t powers_of_10_64[];
    static const uint32_t zero_or_powers_of_10_32[];
    static const uint64_t zero_or_powers_of_10_64[];
    static const uint64_t pow10_significands[];
    static const int16_t pow10_exponents[];
    static const char digits[];
    static const char hex_digits[];
    template <typename Char> struct basic_color {
      static const Char foreground[];
      static const Char background[];
      static const Char reset[];
    };
    using color = basic_color<char>;
    using wcolor = basic_color<wchar_t>;
    data() = delete;
  };

  template <typename T> struct is_char : _VSTD::false_type {};
  template <> struct is_char<char> : _VSTD::true_type {};
  template <> struct is_char<wchar_t> : _VSTD::true_type {};
  template <> struct is_char<char8_t> : _VSTD::true_type {};
  template <> struct is_char<char16_t> : _VSTD::true_type {};
  template <> struct is_char<char32_t> : _VSTD::true_type {};

  template <typename Char>
  inline constexpr bool is_char_v = is_char<Char>::value;

  template <typename Int> using uint_32_64_t =
    _VSTD::conditional_t<_VSTD::numeric_limits<Int>::digits <= 32,
                         uint32_t, uint64_t>;

  template <typename Int> using uint_32_128_t =
    _VSTD::conditional_t<_VSTD::numeric_limits<Int>::digits <= 64,
                         uint_32_64_t<Int>, __uint128_t>;

  template <typename Int> using uint_best_fit_t = uint_32_128_t<Int>;

  template <typename T, _VSTD::enable_if_t<_VSTD::numeric_limits<T>::is_signed,int> = 0>
  inline constexpr bool is_negative(T value) { return value < 0; }

  template <typename T, _VSTD::enable_if_t<!_VSTD::numeric_limits<T>::is_signed,int> = 0>
  inline constexpr bool is_negative(T) { return false; }
  
# ifdef __has_builtin(__builtin_clz)
  // Returns the number of decimal digits in n. Leading zeros are not counted
  // except for n == 0 in which case count_digits returns 1.
  inline int count_digits(uint64_t n) {
    // Based on http://graphics.stanford.edu/~seander/bithacks.html#IntegerLog10
    // and the benchmark https://github.com/localvoid/cxx-benchmark-count-digits.
    int t = (64 - __builtin_clz(n | 1)) * 1233 >> 12;
    return t - (n < data::zero_or_powers_of_10_64[t]) + 1;
  }
# else
  // Fallback version of count_digits used when __builtin_clz is not available.
  inline int count_digits(uint64_t n) {
    int count = 1;
    for (;;) {
      // Integer division is slow so do it for a group of four digits instead
      // of for every digit. The idea comes from the talk by Alexandrescu
      // "Three Optimization Tips for C++". See speed-test for a comparison.
      if (n < 10) return count;
      if (n < 100) return count + 1;
      if (n < 1000) return count + 2;
      if (n < 10000) return count + 3;
      n /= 10000u;
      count += 4;
    }
  }
# endif

  // Counts the number of digits in n. BITS = log2(radix).
  template <unsigned BITS, typename UInt>
  inline int count_digits(UInt n) {
    int num_digits = 0;
    do {
      ++num_digits;
    } while ((n >>= BITS) != 0);
    return num_digits;
  }

  template <> int count_digits<4>(_VSTD::uintptr_t n);

  template <typename Spec, typename Value>
  inline void write_char(const Spec& spec, Value value) {
    auto out = spec.format_context.out();
    *out++ = static_cast<typename Spec::char_type>(value);
    spec.format_context.advance_to(out);
  }

  template <typename Spec, typename Int>
  void write_decimal(const Spec& spec, Int value) {
    using char_type = typename Spec::char_type;
    using uint_type = uint_best_fit_t<Int>;
    auto absvalue = static_cast<uint_type>(value);
    auto negative = is_negative(value);
    auto num_digits = 0;
    auto out = spec.format_context.out();
    if (negative) {
      absvalue = 0 - absvalue;
      num_digits = count_digits(absvalue);
      reserve(out, static_cast<_VSTD::size_t>(num_digits) + 1);
      *out++ = static_cast<char_type>('-');
    } else {
      num_digits = count_digits(absvalue);
      reserve(out, static_cast<_VSTD::size_t>(num_digits));
    }
    assert(num_digits >= 0 && "bad number of digits");
    enum {
          // '-' and digits
          base_size = _VSTD::numeric_limits<uint_type>::digits10 + 1,
          // base size and thousands separators
          buffer_size = base_size + base_size / 3,
    };
    char_type buffer[buffer_size];
    auto end = buffer + buffer_size;
    auto ptr = end;
    while (absvalue >= 100) {
      // Integer division is slow so do it for a group of two digits instead
      // of for every digit. The idea comes from the talk by Alexandrescu
      // "Three Optimization Tips for C++". See speed-test for a comparison.
      //     -- fmtlib by Victor Zverovich
      unsigned index = static_cast<unsigned>((absvalue % 100) * 2);
      absvalue /= 100;
      *--ptr = static_cast<char_type>(data::digits[index + 1]);
      //add_thousands_sep(ptr);
      *--ptr = static_cast<char_type>(data::digits[index]);
      //add_thousands_sep(ptr);
    }
    if (absvalue < 10) {
      *--ptr = static_cast<char_type>('0' + absvalue);
    } else {
      unsigned index = static_cast<unsigned>(absvalue * 2);
      *--ptr = static_cast<char_type>(data::digits[index + 1]);
      //add_thousands_sep(buffer);
      *--ptr = static_cast<char_type>(data::digits[index]);
    }
    spec.format_context.advance_to(_VSTD::copy(ptr, end, out));
  }

  template <typename Spec, typename Float>
  void write_floating(const Spec& spec, Float value) {
#if 0
    if (!_VSTD::isfinite(value)) {
      const char * const str = _VSTD::isinf(value) 
        ? (spec.upper ? "INF" : "inf") 
        : (spec.upper ? "NAN" : "nan");
      auto out = spec.format_context.out();
      out = _VSTD::copy(str, str+3, out);
      if (spec.percentage)
        *++out = static_cast<typename Spec::char_type>('%');
      spec.format_context.advance_to(out);
      return;
    }
#endif
    auto out = spec.format_context.out();
    if (spec.percentage) {
      const auto& s = _VSTD::to_string(value*100);
      out = _VSTD::copy(s.begin(), s.end(), out);
      *++out = static_cast<typename Spec::char_type>('%');
    } else {
      const auto& s = _VSTD::to_string(value);
      out = _VSTD::copy(s.begin(), s.end(), out);
    }
    spec.format_context.advance_to(out);
  }

  struct specbits {
    unsigned fill = 0;
    unsigned width = 0;
    //sign_enum sign = sign_enum::none; // default to minus
    //bool hash : 1 = false;
    bool zero : 1 = false;
    bool upper : 1 = false;
    bool percentage : 1 = false;
  };

  struct none_aligner : specbits {
    // arg
  };

  struct left_aligner : specbits {
  };

  struct right_aligner : specbits {
  };

  struct numeric_aligner : specbits {
  };

  struct center_aligner : specbits {
  };

  template <typename Bits>
  struct none_signer : Bits {
  };

  template <typename Bits>
  struct plus_signer : Bits {
  };

  template <typename Bits>
  struct minus_signer : Bits {
  };

  template <typename Bits>
  struct space_signer : Bits {
  };

  template <typename Bits>
  struct alternate : Bits { // #
  };

  template <typename Bits, chars_format Fmt>
  struct floating : Bits {
    unsigned precision = 0;
  };

  template<typename ParseContext, typename FormatContext>
  struct specification {
    using parse_context_type = ParseContext;
    using format_context_type = FormatContext;
    using char_type = typename FormatContext::char_type;
    ParseContext& parse_context;
    FormatContext& format_context;
  };

  template<typename Value, unsigned Base> struct integral_traits {
    static constexpr auto digits = numeric_limits<Value>::digits * 3 / Base + 1;
    template<typename Iterator>
    inline static auto chars(Iterator begin, Iterator end, Value value)
    { return to_chars(begin, end, value, Base); }
  };
  template<typename Value> struct integral_traits<Value,0> {
    // digits and thousands separators
    // buffer_size = __traits::digits + __traits::digits / 3,
    static constexpr auto digits = numeric_limits<Value>::digits10+1;
    template<typename Iterator>
    inline static auto chars(Iterator begin, Iterator end, Value value)
    { return to_chars(begin, end, value); }
  };

  template<typename Value, typename ParseContext, typename FormatContext, unsigned Base = 0>
  struct integral_spec : specification<ParseContext,FormatContext> {
    inline void operator()(const Value& value) {
      using __traits = integral_traits<Value,Base>;
      using char_type = typename FormatContext::char_type;
      enum { size = __traits::digits };
      char_type buffer[size];
      auto res = __traits::chars(buffer, buffer+size, value);
      if (res.ec != errc(0))
        __throw_format_error("format integer value error");
      else {
        auto out = this->format_context.out();
        out = copy(buffer, res.ptr, out);
        this->format_context.advance_to(out);
      }
    }
  };

  template<typename Char = char> struct bool_cstr {
    auto cstr(bool value) const { return value ? "true" : "false"; }
  };
  template<> struct bool_cstr<wchar_t> {
    auto cstr(bool value) const { return value ? L"true" : L"false"; }
  };

  template<typename SpecBase, typename Char, unsigned Base>
  struct bool_presentation : SpecBase {
    inline void operator()(bool value) {
#if true
      auto out = this->format_context.out();
      *out++ = static_cast<Char>(value ? '1' : '0');
      this->format_context.advance_to(out);
#else
      enum { size = 1 };
      Char buffer[size];
      auto res = to_chars(buffer, buffer+size, unsigned(value), Base);
      if (res.ec != errc(0))
        __throw_format_error("format integer value error");
      else {
        auto out = this->format_context.out();
        out = copy(buffer, res.ptr, out);
        this->format_context.advance_to(out);
      }
#endif
    }
  };

  template<typename SpecBase, typename Char>
  struct bool_presentation<SpecBase,Char,0> : SpecBase, bool_cstr<Char> {
    inline void operator()(bool value) {
      basic_string_view<Char> __s(this->cstr(value));
      auto out = this->format_context.out();
      out = copy(__s.begin(), __s.end(), out);
      this->format_context.advance_to(out);
    }
  };

  template<typename ParseContext, typename FormatContext, unsigned Base>
  struct integral_spec<bool,ParseContext,FormatContext,Base>
    : bool_presentation<specification<ParseContext,FormatContext>,
                        typename FormatContext::char_type,Base> {
    integral_spec(ParseContext& pc, FormatContext& fc)
      : bool_presentation<specification<ParseContext,FormatContext>,
                          typename FormatContext::char_type,Base>{pc, fc} {}
  };

  template<typename ParseContext, typename FormatContext>
  struct integral_spec<char,ParseContext,FormatContext,0>
    : specification<ParseContext,FormatContext> {
    inline void operator()(char value) {
      using char_type = typename FormatContext::char_type;
      auto out = this->format_context.out();
      *out++ = static_cast<char_type>(value); // FIXME: unicode charconv
      this->format_context.advance_to(out);
    }
  };

  template<typename ParseContext, typename FormatContext>
  struct integral_spec<wchar_t,ParseContext,FormatContext,0>
    : specification<ParseContext,FormatContext> {
    inline void operator()(wchar_t value) {
      using char_type = typename FormatContext::char_type;
      auto out = this->format_context.out();
      *out++ = static_cast<char_type>(value); // FIXME: unicode charconv
      this->format_context.advance_to(out);
    }
  };

  template<typename Value, typename ParseContext, typename FormatContext>
  struct floating_spec : specification<ParseContext,FormatContext> {
    unsigned precision = 0;
    bool percentage : 1 = false;
    void operator()(const Value& value) {
      // TODO: deal with precision, etc....
      auto out = this->format_context.out();
      if (this->percentage) {
        using char_type = typename FormatContext::char_type;
        const auto& s = _VSTD::to_string(value*100);
        out = _VSTD::copy(s.begin(), s.end(), out);
        *out++ = static_cast<char_type>('%');
      } else {
        const auto& s = _VSTD::to_string(value);
        out = _VSTD::copy(s.begin(), s.end(), out);
      }
      this->format_context.advance_to(out);
    }
  };

  template<typename ParseContext, typename FormatContext>
  struct default_spec : specification<ParseContext,FormatContext> {
    void operator()(const char* value) {
      this->operator()(basic_string_view<char>(value));
    }
    void operator()(const wchar_t* value) {
      this->operator()(basic_string_view<wchar_t>(value));
    }
    template<typename Char>
    void operator()(const basic_string<Char>& __s) {
      this->copy_str(__s.begin(), __s.end());
    }
    template<typename Char>
    void operator()(basic_string_view<Char> __s) {
      this->copy_str(__s.begin(), __s.end());
    }

    template<typename Value>
    void operator()(const Value& value) {
      __throw_format_error("default specification for unexpected value");
    }

  private:
    template<typename Iterator>
    void copy_str(Iterator begin, Iterator end) const {
      auto out = this->format_context.out();
      out = copy(begin, end, out);
      this->format_context.advance_to(out);
    }
  };

  template<typename ParseContext, typename FormatContext>
  struct pointer_spec : specification<ParseContext,FormatContext> {
    template<typename T> inline void operator()(const T* value) {
      using __traits = integral_traits<uintptr_t,16>;
      using char_type = typename FormatContext::char_type;
      enum { size = __traits::digits };
      char_type buffer[size];
      auto __v = reinterpret_cast<uintptr_t>(value);
      auto res = __traits::chars(buffer, buffer+size, __v);
      if (res.ec != errc(0))
        __throw_format_error("format integer value error");
      else {
        auto out = this->format_context.out();
        *out++ = static_cast<char_type>('0');
        *out++ = static_cast<char_type>('x'); // FIXME: upper 'X'
        out = copy(buffer, res.ptr, out);
        this->format_context.advance_to(out);
      }
    }
  };

  template<typename ParseContext, typename FormatContext>
  struct unmatched_type_spec : specification<ParseContext,FormatContext> {
    template<typename Value>
    void operator()(const Value& value) {
      __throw_format_error("format value of unmatched type");
    }
  };

  template <typename OutIter, typename Char> class driver final {
    using FormatContext = basic_format_context<OutIter,Char>;
    FormatContext format_context;

    template <typename Iterator>
    void chars(Iterator& pos, const Iterator end) {
      auto out = _VSTD::copy(pos, end, format_context.out());
      format_context.advance_to(out);
    }

    void escape(Char character) {
      auto out = format_context.out();
      *out = character;
      ++out;
      format_context.advance_to(out);
    }

    template <typename Iterator>
    int positive_int(Iterator& pos, const Iterator end) {
      assert(pos != end && '0' <= *pos && *pos <= '9');
      if (*pos == '0') {
        ++pos;
        return 0;
      }
      unsigned val = 0;
      unsigned max = std::numeric_limits<int>::max();
      unsigned top = max / 10;
      do {
        val = val * 10 + unsigned(*pos - '0');
        ++pos;
        if (val > top) { // overflow
          val = top + 1;
          break;
        }
      } while (pos != end && '0' <= *pos && *pos <= '9');
      return static_cast<int>(val);
    }

    template <typename ParseContext, typename Iterator>
    auto arg_id(ParseContext& pc, Iterator& pos, const Iterator end) {
      _VSTD::size_t id;
      auto c = *pos;
      if ('0' <= c && c <= '9') {
        id = this->positive_int(pos, end);
        pc.check_arg_id(id);
      } else {
        id = pc.next_arg_id();
      }
      return id;
    }

    template <typename ParseContext, typename Iterator>
    void replacement(ParseContext& pc, Iterator& pos, const Iterator end) {
      assert(*pos == '{' && "unexpected replacement openning");
      ++pos;
      if (pos == end) {
        __throw_format_error("malform format string");
      }
      const auto id = this->arg_id(pc, pos, end);
      if (pos == end) {
        __throw_format_error("malform format string");
      } else if (*pos == ':') {
        ++pos;
        this->spec_align(pc, id, pos, end);
      } else if (*pos == '}') {
        ++pos;
        this->handle_arg(pc, format_context.arg(id), none_aligner{});
      } else {
        __throw_format_error("malform format replacement");
      }
    }

    template <typename ParseContext, typename Iterator>
    void spec_align(ParseContext& pc, _VSTD::size_t id, Iterator& pos, const Iterator end) {
      if (pos == end) {
        __throw_format_error("malform format replacement spec");
      } else if (*pos == '}') {
        ++pos;
        this->handle_arg(pc, format_context.arg(id), none_aligner{});
        return;
      } else if (auto next = pos + 1; next != end) {
        switch (*next) {
        case '<': {
          left_aligner bits{ static_cast<unsigned>(*pos) };
          if (bits.fill == '{')
            __throw_format_error("invalid fill character '{'");
          pos += 2;
          this->spec_sign(bits, pc, id, pos, end);
        } break;
        case '>': {
          right_aligner bits{ static_cast<unsigned>(*pos) };
          if (bits.fill == '{')
            __throw_format_error("invalid fill character '{'");
          pos += 2;
          this->spec_sign(bits, pc, id, pos, end);
        } break;
        case '=': {
          numeric_aligner bits{ static_cast<unsigned>(*pos) };
          if (bits.fill == '{')
            __throw_format_error("invalid fill character '{'");
          pos += 2;
          this->spec_sign(bits, pc, id, pos, end);
        } break;
        case '^': {
          center_aligner bits{ static_cast<unsigned>(*pos) };
          if (bits.fill == '{')
            __throw_format_error("invalid fill character '{'");
          pos += 2;
          this->spec_sign(bits, pc, id, pos, end);
        } break;
        default:
          switch (*pos) {
          case '<':
            pos = next;
            this->spec_sign(left_aligner{}, pc, id, pos, end);
            break;
          case '>':
            pos = next;
            this->spec_sign(right_aligner{}, pc, id, pos, end);
            break;
          case '=':
            pos = next;
            this->spec_sign(numeric_aligner{}, pc, id, pos, end);
            break;
          case '^':
            pos = next;
            this->spec_sign(center_aligner{}, pc, id, pos, end);
            break;
          default:
            this->spec_sign(none_aligner{}, pc, id, pos, end);
            break;
          }
        }
      } else {
        __throw_format_error("malform format spec");
      }
    }

    template <typename Bits, typename ParseContext, typename Iterator>
    void spec_sign(Bits bits, ParseContext& pc, _VSTD::size_t id, Iterator& pos, const Iterator end) {
      if (pos == end)
        __throw_format_error("malform format spec");
      switch (*pos) {
      case '+':
        ++pos;
        this->spec_alt(plus_signer<Bits>{ bits }, pc, id, pos, end);
        break;
      case '-':
        ++pos;
        this->spec_alt(minus_signer<Bits>{ bits }, pc, id, pos, end);
        break;
      case ' ':
        ++pos;
        this->spec_alt(space_signer<Bits>{ bits }, pc, id, pos, end);
        break;
      default:
        this->spec_alt(none_signer<Bits>{ bits }, pc, id, pos, end);
        break;
      }
    }

    template <typename Bits, typename ParseContext, typename Iterator>
    void spec_alt(Bits bits, ParseContext& pc, _VSTD::size_t id, Iterator& pos, const Iterator end) {
      if (pos == end) {
        __throw_format_error("malform format replacement spec");
      } else if (*pos == '#') {
        ++pos;
        this->spec_width(alternate<Bits>{ bits }, pc, id, pos, end);
      } else {
        this->spec_width(bits, pc, id, pos, end);
      }
    }

    template <typename Bits, typename ParseContext, typename Iterator>
    void spec_width(Bits bits, ParseContext& pc, _VSTD::size_t id, Iterator& pos, const Iterator end) {
      if (pos == end) {
        __throw_format_error("malform format replacement spec");
      } else if (*pos == '0') {
        bits.zero = true;
        ++pos;
      }
      if (pos == end) {
        __throw_format_error("malform format replacement spec");
      } else if ('1' <= *pos && *pos <= '9') {
        bits.width = positive_int(pos, end);
      }
      unsigned precision = 0;
      if (pos != end && *pos == '.') {
        if (++pos == end) {
          __throw_format_error("malform format replacement spec");
        } else {
          precision = positive_int(pos, end);
        }
      }
      if (pos == end)
        __throw_format_error("malform format replacement spec");
      const auto type = *pos++;
      if (type == '}') {
        this->handle_arg(pc, format_context.arg(id), bits);
        return;
      }
      if (*pos != '}') {
        __throw_format_error("malform format replacement spec");
      } else {
        auto arg = format_context.arg(id);
        ++pos;
        switch (type) { // presentation type
        case 'a':
          this->handle_floating(pc, arg, floating<Bits,chars_format::hex>{ bits, precision });
          break;
        case 'A':
          bits.upper = true;
          this->handle_floating(pc, arg, floating<Bits,chars_format::hex>{ bits, precision });
          break;
        case 'b':
          this->handle_integral<2>(pc, arg, bits);
          break;
        case 'B':
          bits.upper = true;
          this->handle_integral<2>(pc, arg, bits);
          break;
        case 'c':
          this->handle_character(pc, arg, bits);
          break;
        case 'd':
          this->handle_integral<10>(pc, arg, bits);
          break;
        case 'e':
          if (precision == 0) precision = 6;
          this->handle_floating(pc, arg, floating<Bits,chars_format::scientific>{ bits, precision });
          break;
        case 'E':
          bits.upper = true;
          if (precision == 0) precision = 6;
          this->handle_floating(pc, arg, floating<Bits,chars_format::scientific>{ bits, precision });
          break;
        case 'f':
          if (precision == 0) precision = 6;
          this->handle_floating(pc, arg, floating<Bits,chars_format::fixed>{ bits, precision });
          break;
        case 'F':
          bits.upper = true;
          if (precision == 0) precision = 6;
          this->handle_floating(pc, arg, floating<Bits,chars_format::fixed>{ bits, precision });
          break;
        case 'g':
          if (precision == 0) precision = 6;
          this->handle_floating(pc, arg, floating<Bits,chars_format::general>{ bits, precision });
          break;
        case 'G':
          bits.upper = true;
          if (precision == 0) precision = 6;
          this->handle_floating(pc, arg, floating<Bits,chars_format::general>{ bits, precision });
          break;
        case 'n':
          this->handle_numeric(pc, arg, bits);
          break;
        case 'o':
          this->handle_integral<8>(pc, arg, bits);
          break;
        case 'p':
          this->handle_pointer(pc, arg, bits);
          break;
        case 's':
          this->handle_string(pc, arg, bits);
          break;
        case 'x':
          this->handle_integral<16>(pc, arg, bits);
          break;
        case 'X':
          bits.upper = true;
          this->handle_integral<16>(pc, arg, bits);
          break;
        case '%':
          // TODO: floating point as percentage
          break;
        }
      }
    }

    template <typename ParseContext, typename FormatArg, typename Bits>
    void handle_arg(ParseContext& parse_context, FormatArg arg, Bits bits) {
      visit_format_arg([this, &parse_context](const auto &value){
        using Value = remove_cvref_t<decltype(value)>;
        conditional_t<is_floating_point_v<Value>,floating_spec<Value,ParseContext,FormatContext>,
        conditional_t<is_integral_v<Value>,integral_spec<Value,ParseContext,FormatContext>,
                      default_spec<ParseContext,FormatContext>>>
          spec{ parse_context, format_context };
        spec(value);
      }, arg);
    }

    template <typename ParseContext, typename FormatArg, typename Bits>
    void handle_floating(ParseContext& parse_context, FormatArg arg, Bits bits) {
      visit_format_arg([this, &parse_context](const auto &value){
        using Value = remove_cvref_t<decltype(value)>;
        conditional_t<is_floating_point_v<Value>,floating_spec<Value,ParseContext,FormatContext>,
                      unmatched_type_spec<ParseContext,FormatContext>>
          spec{ parse_context, format_context };
        spec(value);
      }, arg);
    }

    template <unsigned Base, typename ParseContext, typename FormatArg, typename Bits>
    void handle_integral(ParseContext& parse_context, FormatArg arg, Bits bits) {
      visit_format_arg([this, &parse_context](const auto &value){
        using Value = remove_cvref_t<decltype(value)>;
        conditional_t<is_integral_v<Value>,integral_spec<Value,ParseContext,FormatContext,Base>,
                      unmatched_type_spec<ParseContext,FormatContext>>
          spec{ parse_context, format_context };
        spec(value);
      }, arg);
    }

    template <typename ParseContext, typename FormatArg, typename Bits>
    void handle_numeric(ParseContext& parse_context, FormatArg arg, Bits bits) {
      visit_format_arg([this, &parse_context](const auto &value){
        using Value = remove_cvref_t<decltype(value)>;
        conditional_t<is_floating_point_v<Value>,floating_spec<Value,ParseContext,FormatContext>,
        conditional_t<is_integral_v<Value>,integral_spec<Value,ParseContext,FormatContext,10>,
                      unmatched_type_spec<ParseContext,FormatContext>>>
          spec{ parse_context, format_context };
        spec(value);
      }, arg);
    }

    template <typename ParseContext, typename FormatArg, typename Bits>
    void handle_character(ParseContext& parse_context, FormatArg arg, Bits bits) {
      visit_format_arg([this, &parse_context](const auto &value){
        using Value = remove_cvref_t<decltype(value)>;
        conditional_t<is_char_v<Value>,integral_spec<Value,ParseContext,FormatContext,0>,
                      unmatched_type_spec<ParseContext,FormatContext>>
          spec{ parse_context, format_context };
        spec(value);
      }, arg);
    }

    template <typename ParseContext, typename FormatArg, typename Bits>
    void handle_pointer(ParseContext& parse_context, FormatArg arg, Bits bits) {
      visit_format_arg([this, &parse_context](const auto &value){
        using Value = remove_cvref_t<decltype(value)>;
        conditional_t<is_pointer_v<Value>,pointer_spec<ParseContext,FormatContext>,
                      unmatched_type_spec<ParseContext,FormatContext>>
          spec{ parse_context, format_context };
        spec(value);
      }, arg);
    }

    template <typename ParseContext, typename FormatArg, typename Bits>
    void handle_string(ParseContext& parse_context, FormatArg arg, Bits bits) {
      visit_format_arg([this, &parse_context](const auto &value){
        using Value = remove_cvref_t<decltype(value)>;
        conditional_t<is_char_v<Value>,default_spec<ParseContext,FormatContext>,
                      unmatched_type_spec<ParseContext,FormatContext>>
          spec{ parse_context, format_context };
        spec(value);
      }, arg);
    }

  public:
    template <typename FormatArgs>
    driver(OutIter out, FormatArgs args) : format_context(out, args) {}

    template <typename ParseContext>
    constexpr OutIter operator()(ParseContext& context) {
      using char_type = typename ParseContext::char_type;
      auto const end = context.end();
      auto pos = context.begin();
      auto last = pos;
      while (pos != end) {
        switch (*pos) {
        case '{': {
          if (last < pos) this->chars(last, pos);
          auto next = pos + 1;
          if (next == end) {
            // finish
          } else if (*next == '{') {
            ++next;
            this->escape(*pos);
            pos = next;
          } else {
            this->replacement(context, pos, end);
          }
          last = pos;
        } break;
        case '}': { // unbalanced close brace
          if (last < pos) this->chars(last, pos);
          auto next = pos + 1;
          if (next == end) {
            pos = end; // finish
          } else if (*next == '}') {
            ++next;
            this->escape(*pos);
            last = pos = next;
          } else {
            this->chars(pos, next);
            last = pos = end;
          }
        } break;
        default: ++pos;
        }
      }
      if (last < pos) this->chars(last, pos);
      context.advance_to(pos);
      return format_context.out();
    }
  };

  template <typename Char>
  class basic_string_inserter
    : public _VSTD::back_insert_iterator<_VSTD::basic_string<Char>>
  {
  public:
    explicit basic_string_inserter(_VSTD::basic_string<Char>& __x)
      : _VSTD::back_insert_iterator<_VSTD::basic_string<Char>>(__x) {}
    void reserve(_VSTD::size_t size) { this->container->reserve(size); }
  };

  template <typename Char>
  using basic_string_format_context = basic_format_context<basic_string_inserter<Char>,Char>;
} // __format

using format_context = __format::basic_string_format_context<char>;
using wformat_context = __format::basic_string_format_context<wchar_t>;

template<class T, class Char> struct formatter
{
  // T is unsupported by standard formatter, you have to specialize
  // std::formatter<T,Char> in your code.
  formatter() = delete;
};

namespace __format
{
  // selecting smaller type

  template <typename T, typename... Types> struct smaller;
  template <typename T, typename Type>
  struct smaller<T,Type> { using type = Type; };

  template <typename T, typename Type, typename... Rest>
  struct smaller<T,Type,Rest...> : conditional_t<(sizeof(T)<=sizeof(Type)),
    smaller<T,Type>, smaller<T,Rest...>> {};

  template <typename T, typename... Types>
  using smaller_t = typename smaller<T,Types...>::type;

# if 0
  template <typename T, bool = _VSTD::is_integral_v<T>> struct integer
  {
    using Int = _VSTD::conditional_t<
      _VSTD::is_unsigned_v<T>,
      smaller_t<T,unsigned int,unsigned long long int>,
      smaller_t<T,int,long long int>>;
    Int val(const T& v) noexcept { return static_cast<Int>(v); }
  };
# endif

  // integer

  template <typename T, bool = _VSTD::is_unsigned_v<T>>
  struct fit_integer
  {
    using type = smaller_t<T,unsigned int,unsigned long long int>;
  };
  template <typename T> struct fit_integer<T,false>
  {
    using type = smaller_t<T,int,long long int>;
  };
} // __format

template<class Context, class... Args> struct format_arg_store;

template<class Context> class basic_format_arg {
public:
  class handle;

private:
  using char_type = typename Context::char_type;

  _VSTD::variant<
    _VSTD::monostate, bool, char_type, int, unsigned int,
    long long int, unsigned long long int, double, long double,
    const char_type*, basic_string_view<char_type>,
    const void*, handle> var;

  template<class X, class... Args>
  friend struct format_arg_store;

  // integer

  template <typename T, bool = _VSTD::is_integral_v<T>>
  struct integer : __format::fit_integer<T>
  {
    using typename __format::fit_integer<T>::type;
    type val(const T& v) const noexcept { return static_cast<type>(v); }
  };

  template <typename T> struct integer<T,false> {
    handle val(const T& v) const noexcept { return handle(v); }
  };

  template <typename T> struct identical {
    T val(T v) const noexcept { return v; }
  };

  template <typename T> struct best_store : integer<T> {};
  template <> struct best_store<bool> : identical<bool> {};
  template <> struct best_store<char> : identical<char> {};
  template <> struct best_store<wchar_t> : identical<wchar_t> {};
  template <> struct best_store<char8_t> : identical<char8_t> {};
  template <> struct best_store<char16_t> : identical<char16_t> {};
  template <> struct best_store<char32_t> : identical<char32_t> {};

  template<class T> explicit basic_format_arg(const T& v) noexcept
    : var(best_store<T>().val(v)) {}

  explicit basic_format_arg(float n) noexcept : var(static_cast<double>(n)) {}
  explicit basic_format_arg(double n) noexcept : var(n) {}
  explicit basic_format_arg(long double n) noexcept : var(n) {}
  explicit basic_format_arg(const char_type* s) : var(s) {}

  template<class Traits>
  explicit basic_format_arg(basic_string_view<char_type,Traits> s) noexcept
    : var(s) {}

  template<class Traits, class Allocator>
  explicit basic_format_arg(const basic_string<char_type,Traits,Allocator>& s) noexcept
    : basic_format_arg(basic_string_view(s.data(), s.size())) {}

  explicit basic_format_arg(nullptr_t) noexcept
    : var(static_cast<const void*>(nullptr)) {}

  explicit basic_format_arg(const void* p) noexcept
    : var(p) {}

  template<class Visitor, class Ctx>
  friend auto visit_format_arg(Visitor&& visit, basic_format_arg<Ctx> arg)
    -> decltype(visit(0));

  template<class Ctx, class... Args>
  friend format_arg_store<Ctx, Args...> make_format_args(const Args&... args);

public:
  basic_format_arg() noexcept {}
  explicit operator bool() const noexcept {
    return !_VSTD::holds_alternative<_VSTD::monostate>(var);
  }
};

template<class Context>
class basic_format_arg<Context>::handle {
  friend class basic_format_arg<Context>;

  using char_type = typename Context::char_type;
  using parse_context = basic_format_parse_context<char_type>;

  template<typename T>
  using formatter = typename Context::template formatter_type<T>;

  const void* ptr;
  void (*fmt)(parse_context&, Context&, const void*);

  template<class T> explicit handle(const T& val) noexcept
    : ptr(&val)
    , fmt([](parse_context& parse_ctx, Context& format_ctx, const void* ptr) {
        formatter<T> __f;
        auto& val = *static_cast<const T*>(ptr);
        parse_ctx.advance_to(__f.parse(parse_ctx));
        format_ctx.advance_to(__f.format(val, format_ctx));
      })
  {}

public:
  void format(parse_context& parse_ctx, Context& format_ctx) const
  { fmt(parse_ctx, format_ctx, ptr); }
};

namespace __format
{
#if 0
  template<typename T> struct handle<basic_format_arg<T>> {
    template<typename Spec>
    void format(const Spec& spec, basic_format_arg<T> arg) const {
      visit_format_arg([this, &spec](const auto& val){
        using val_type = _VSTD::remove_cvref_t<decltype(val)>;
        handle<val_type>().format(spec, val);
      }, arg);
    }
  };
#endif
#if __has_feature(ASSOCIATED_TYPENAME_SPECIALIZATION)
  template<typename FormatContext>
  struct handle<typename basic_format_arg<FormatContext>::handle> {
    template<typename ParseContext>
    void format(const Spec& spec, typename basic_format_arg<FormatContext>::handle h) const {
      h.format(spec);
    }
  };
#endif // ASSOCIATED_TYPENAME_SPECIALIZATION
}

#if false

namespace __format
{
  template<class Ret, class Visitor, typename... Types> struct visit_by_type;
  template<class Ret, class Visitor> struct visit_by_type<Ret, Visitor>
  {
    template<class Ctx>
    Ret apply(Visitor&& visit, basic_format_arg<Ctx> arg)
    { return visit(monostate()); }
  };

  template<class Ret, class Visitor, typename T, typename... Rest>
  struct visit_by_type<Ret, Visitor, T, Rest...>
  {
    template<class Ctx>
    Ret apply(Visitor&& visit, basic_format_arg<Ctx> arg)
    {
      if (arg.type == &typeid(T))
        return visit(*reinterpret_cast<T*>(&arg.int_value));
      else
        return visit_by_type<Ret,Visitor,Rest...>().apply(visit, arg);
    }
  };
} // __format

template<class Visitor, class Ctx> inline auto
visit_format_arg(Visitor&& visitor, basic_format_arg<Ctx> arg)
  -> decltype(visitor(0))
{
  using handle = typename basic_format_arg<Ctx>::handle;
  using char_type = typename basic_format_arg<Ctx>::char_type;
  __format::visit_by_type
    <decltype(visitor(0)), Visitor,
     monostate, bool, char_type, int, unsigned int,
     long long int, unsigned long long int, double, long double,
     const char_type*, basic_string_view<char_type>,
     const void*, handle> by_type;
  return by_type.apply(move(visitor), arg);
}

#else

template<class Visitor, class Ctx> inline auto
visit_format_arg(Visitor&& visitor, basic_format_arg<Ctx> arg)
  -> decltype(visitor(0))
{ return _VSTD::visit(move(visitor), arg.var); }

#endif

namespace __format
{
  template <typename Char> inline basic_string_inserter<Char>&&
  reserve(basic_string_inserter<Char>&& it, _VSTD::size_t size) {
    it.reserve(size);
    return move(it);
  }

  inline char8_t to_char8_t(char c) { return static_cast<char8_t>(c); }

  template <typename InputIt, typename OutChar>
  constexpr const bool needs_conversion = _VSTD::bool_constant<
    _VSTD::is_same<typename _VSTD::iterator_traits<InputIt>::value_type, char>::value &&
    _VSTD::is_same<OutChar, char8_t>::value>::value;

  template <typename OutChar, typename InputIt, typename OutputIt,
            _VSTD::enable_if_t<!needs_conversion<InputIt,OutChar>,int> = 0>
  OutputIt copy_str(InputIt begin, InputIt end, OutputIt it) {
    return _VSTD::copy(begin, end, it);
  }

  template <typename OutChar, typename InputIt, typename OutputIt,
            _VSTD::enable_if_t<needs_conversion<InputIt,OutChar>,int> = 0>
  OutputIt copy_str(InputIt begin, InputIt end, OutputIt it) {
    return _VSTD::transform(begin, end, it, to_char8_t);
  }

} // __format

template<class Context, class... Args>
struct format_arg_store {
  _VSTD::array<basic_format_arg<Context>,sizeof...(Args)> args;
  format_arg_store(const Args&... args)
    : args{ basic_format_arg<Context>(args)... } {}
};

template<class Context = format_context, class... Args>
inline format_arg_store<Context,Args...>
make_format_args(const Args&... args) { return {args...}; }

template<class... Args>
inline format_arg_store<wformat_context,Args...>
make_wformat_args(const Args&... args) { return {args...}; }

template<class Context> class basic_format_args {
  const basic_format_arg<Context>* args;
  size_t num_args;

public:
  basic_format_args() noexcept;

  template<class... Args>
  basic_format_args(const format_arg_store<Context,Args...>& store) noexcept
    : args(store.args.data()), num_args(store.args.size()) {}

  basic_format_arg<Context> get(_VSTD::size_t i) const noexcept
  { return i < num_args ? args[i] : basic_format_arg<Context>(); }
};

#if 0
template<typename T,typename Char>
struct formatter<T,Char>
{
  template <typename FormatContext>
  constexpr typename FormatContext::iterator
  format(FormatContext& context) {
    auto specifier = this->parsed_specifier();
    if (specifier) specifier->write(context, 0);
    return context.out();
  }
};
#endif

namespace __format
{
  template<typename Char>
  using basic_string_format_args = basic_format_args<basic_string_format_context<Char>>;

  void as_string_view(...);

  template<typename Char, _VSTD::enable_if<is_char_v<Char>>>
  inline basic_string_view<Char>
  as_string_view(const Char* s) { return {s}; }

  template<typename Char, typename Traits, typename Allocator>
  inline basic_string_view<Char>
  as_string_view(const _VSTD::basic_string<Char,Traits,Allocator>& s)
  { return {s.data(), s.size()}; }

  template<typename Char, typename Traits>
  inline basic_string_view<Char>
  as_string_view(basic_string_view<Char,Traits> s)
  { return {s.data(), s.size()}; }

  template <typename S>
  struct is_string : _VSTD::is_class<decltype(as_string_view(_VSTD::declval<S>()))> {};

  template <> struct is_string<void> : _VSTD::false_type {};

  template<typename S>
  inline constexpr bool is_string_v = is_string<S>::value;

  template<typename S, typename=void> struct associated_char {};
  template<typename S> struct associated_char<S,_VSTD::enable_if_t<is_string_v<S>>> {
    using string_view = decltype(as_string_view(_VSTD::declval<S>()));
    using type = typename string_view::value_type;
  };

  template <typename S>
  using char_t = typename associated_char<S>::type;
} // __format

using format_args = __format::basic_string_format_args<char>;
using wformat_args = __format::basic_string_format_args<wchar_t>;

template<typename Out, typename Char>
using format_args_t = basic_format_args<basic_format_context<Out,Char>>;

template<typename Out, typename S, typename Char = __format::char_t<S>>
inline Out vformat_to(Out out, const S& fmt, format_args_t<Out,Char> args)
{
  basic_format_parse_context<Char> parse_context(fmt);
  __format::driver<Out,Char> drive(out, args);
  return drive(parse_context);
}

template<class S, class Context, typename Char = __format::char_t<S>>
inline auto vformat(const S& fmt, basic_format_args<Context> args) {
  _VSTD::basic_string<Char> buffer;
  __format::basic_string_inserter<Char> out(buffer);
  vformat_to(out, fmt, args);
  return buffer;
}

template<typename S, typename... Args, typename Char = __format::char_t<S>>
inline auto format(const S& fmt, const Args&... args) {
  using Context = __format::basic_string_format_context<Char>;
  auto store = make_format_args<Context>(args...);
  const basic_format_args<Context> va(store);
  return vformat(fmt, va);
}

template<typename Char, int N, class... Args>
inline auto format(const Char fmt[N], const Args&... args) {
# if 0
  return format(__format::as_string_view(fmt), args...);
# else
  return format(_VSTD::basic_string_view<Char>(fmt,N), args...);
# endif
}

template<typename Char, class... Args>
inline auto format(const Char* fmt, const Args&... args) {
# if 0
  return format(__format::as_string_view(fmt), args...);
# else
  return format(_VSTD::basic_string_view<Char>(fmt), args...);
# endif
}

_LIBCPP_END_NAMESPACE_STD
