// -*- C++ -*-
//===--------------------------- format -----------------------------------===//
//
//    Copyright (c) 2018-2019 Duzy Chan and ExtBit Limited.
//    This file is part of ExtC++, the ExtBit C++ standard library.
//
//    <format> implements jtc1/sc22/wg21/docs/papers/2019/p0645r9,
//    insipred by the fmtlib by Victor Zverovich.
//
//===----------------------------------------------------------------------===//
#pragma once
#pragma GCC system_header
#if defined(format_synopsis)
namespace std {
  // [format.error], class format_error
  class format_error;

  // [format.formatter], formatter
  template<class Char> class basic_format_parse_context;
  using format_parse_context = basic_format_parse_context<char>;
  using wformat_parse_context = basic_format_parse_context<wchar_t>;
  
  template<class Out, class Char> class basic_format_context;
  using format_context = basic_format_context<unspecified, char>;
  using wformat_context = basic_format_context<unspecified, wchar_t>;

  template<class T, class Char = char> struct formatter;
  
  // [format.arguments], arguments
  template<class Context> class basic_format_arg;

  template<class Visitor, class Context>
    see_below visit_format_arg(Visitor&& vis, basic_format_arg<Context> arg);

  template<class Context, class... Args> struct format_arg_store; // exposition only

  template<class Context> class basic_format_args;
  using format_args = basic_format_args<format_context>;
  using wformat_args = basic_format_args<wformat_context>;

  template<class Out, class Char>
    using format_args_t = basic_format_args<basic_format_context<Out, Char>>;

  template<class Context = format_context, class... Args>
    format_arg_store<Context, Args...>
      make_format_args(const Args&... args);
  template<class... Args>
    format_arg_store<wformat_context, Args...>
      make_wformat_args(const Args&... args);

  // [format.functions], formatting functions
  template<class... Args>
    string format(string_view fmt, const Args&... args);
  template<class... Args>
    wstring format(wstring_view fmt, const Args&... args);

  string vformat(string_view fmt, format_args args);
  wstring vformat(wstring_view fmt, wformat_args args);

  template<class Out, class... Args>
    Out format_to(Out out, string_view fmt, const Args&... args);
  template<class Out, class... Args>
    Out format_to(Out out, wstring_view fmt, const Args&... args);

  template<class Out>
    Out vformat_to(Out out, string_view fmt, format_args_t<Out, char> args);
  template<class Out>
    Out vformat_to(Out out, wstring_view fmt, format_args_t<Out, wchar_t> args);

  template<class Out>
    struct format_to_n_result {
      Out out;
      iter_difference_t<Out> size;
    };
  
  template<class Out, class... Args>
    format_to_n_result<Out> format_to_n(Out out, iter_difference_t<Out> n,
                                        string_view fmt, const Args&... args);
  template<class Out, class... Args>
    format_to_n_result<Out> format_to_n(Out out, iter_difference_t<Out> n,
                                        wstring_view fmt, const Args&... args);

  template<class... Args>
    size_t formatted_size(string_view fmt, const Args&... args);
  template<class... Args>
    size_t formatted_size(wstring_view fmt, const Args&... args);
}
#endif

#include <__config>
#include <charconv>
#include <stdexcept>
#include <string_view>
#include <string>
#include <stdint.h>
#include <variant>
#include <array>
#include <iostream>

_LIBCPP_BEGIN_NAMESPACE_STD

class format_error : public runtime_error
{
public:
  explicit format_error(const string& message) : runtime_error(message) {}
  explicit format_error(const char* message) : runtime_error(message) {}
};

#define __FORMAT_ERROR_MSX(MSG) #MSG
#define __FORMAT_ERROR_MSG(MSG) __FORMAT_ERROR_MSX(MSG)
#define __THROW_FORMAT_ERROR(MSG)                               \
  __throw_format_error(MSG " @" __FORMAT_ERROR_MSG(__LINE__))

[[noreturn]] inline _LIBCPP_INLINE_VISIBILITY
void __throw_format_error(const char*__msg)
{
#ifndef _LIBCPP_NO_EXCEPTIONS
    throw format_error(__msg);
#else
    ((void)__msg);
    _VSTD::abort();
#endif
}

template <typename Char>
class basic_format_parse_context {
  basic_string_view<Char> fmt_;
  enum { unknown, manual, automatic } indexing_;
  size_t next_arg_id_;
  size_t num_args_;

  basic_format_parse_context(const basic_format_parse_context&) = delete;
  basic_format_parse_context& operator=(const basic_format_parse_context&) = delete;

public:
  using char_type = Char;
  using const_iterator = typename basic_string_view<Char>::const_iterator;
  using iterator = const_iterator;

  explicit constexpr basic_format_parse_context(basic_string_view<Char> fmt, size_t num_args = 0) noexcept
    : fmt_(fmt), indexing_(unknown), next_arg_id_(0), num_args_(num_args) {}

  constexpr const_iterator begin() const noexcept { return fmt_.begin(); }
  constexpr const_iterator end() const noexcept { return fmt_.end(); }
  constexpr void advance_to(const_iterator it) {
    // Expects: end() is reachable from it.
    // static_cast<make_unsigned_t<?>>(it - begin());
    fmt_.remove_prefix(static_cast<size_t>(it - begin()));
  }

  constexpr int next_arg_id() {
    if (indexing_ == manual)
      __THROW_FORMAT_ERROR("mixing of automatic and manual argument indexing");
    else if (indexing_ == unknown)
      indexing_ = automatic;
    return next_arg_id_++;
  }

  constexpr void check_arg_id(size_t id) {
    // Expects: next_arg_id_ < num_args_
    if (indexing_ == automatic)
      __THROW_FORMAT_ERROR("mixing of automatic and manual argument indexing");
    else if (indexing_ == unknown)
      indexing_ = manual;
  }
};

using format_parse_context = basic_format_parse_context<char>;
using wformat_parse_context = basic_format_parse_context<wchar_t>;

template <typename Context> class basic_format_arg;
template <typename Context> class basic_format_args;
template<class T, class Char = char> struct formatter;

template <typename OutIter, typename Char>
class basic_format_context
{
  using format_args = basic_format_args<basic_format_context>;

private:
  OutIter out_;
  format_args args_;

  basic_format_context(const basic_format_context&) = delete;
  void operator=(const basic_format_context&) = delete;

public:
  using char_type = Char;
  using iterator = OutIter;
  using format_arg = basic_format_arg<basic_format_context>;
  template <typename T> using formatter_type = formatter<T,Char>;

  basic_format_context(OutIter out, format_args args)
    : out_(out), args_(args) {}

  format_arg arg(int id) const { return args_.get(id); }
  iterator out() { return out_; }
  void advance_to(iterator it) { out_ = it; }
};

namespace __format
{
  template <typename Char>
  class basic_string_inserter
    : public back_insert_iterator<basic_string<Char>>
  {
  public:
    explicit basic_string_inserter(basic_string<Char>& __x)
      : back_insert_iterator<basic_string<Char>>(__x) {}
    void reserve(size_t size) { this->container->reserve(size); }
  };

  template <typename Char>
  using basic_string_format_context = basic_format_context<basic_string_inserter<Char>,Char>;

#if 0
  template <typename Char> inline basic_string_inserter<Char>&&
  reserve(basic_string_inserter<Char>&& it, size_t size) {
    it.reserve(size);
    return move(it);
  }

  inline char8_t to_char8_t(char c) { return static_cast<char8_t>(c); }

  template <typename InputIt, typename OutChar>
  constexpr const bool needs_conversion = bool_constant<
    is_same<typename iterator_traits<InputIt>::value_type, char>::value &&
    is_same<OutChar, char8_t>::value>::value;

  template <typename OutChar, typename InputIt, typename OutputIt,
            enable_if_t<!needs_conversion<InputIt,OutChar>,int> = 0>
  OutputIt copy_str(InputIt begin, InputIt end, OutputIt it) {
    return copy(begin, end, it);
  }

  template <typename OutChar, typename InputIt, typename OutputIt,
            enable_if_t<needs_conversion<InputIt,OutChar>,int> = 0>
  OutputIt copy_str(InputIt begin, InputIt end, OutputIt it) {
    return transform(begin, end, it, to_char8_t);
  }
#endif
} // __format

using format_context = __format::basic_string_format_context<char>;
using wformat_context = __format::basic_string_format_context<wchar_t>;

template<class T, class Char> struct formatter
{
  // T is unsupported by standard formatter, you have to specialize
  // std::formatter<T,Char> in your code.
  formatter() = delete;
};

namespace __format
{
  // selecting smaller type

  template <typename T, typename... Types> struct smaller;
  template <typename T, typename Type>
  struct smaller<T,Type> { using type = Type; };

  template <typename T, typename Type, typename... Rest>
  struct smaller<T,Type,Rest...> : conditional_t<(sizeof(T)<=sizeof(Type)),
    smaller<T,Type>, smaller<T,Rest...>> {};

  template <typename T, typename... Types>
  using smaller_t = typename smaller<T,Types...>::type;

# if 0
  template <typename T, bool = is_integral_v<T>> struct integer
  {
    using Int = conditional_t<
      is_unsigned_v<T>,
      smaller_t<T,unsigned int,unsigned long long int>,
      smaller_t<T,int,long long int>>;
    Int val(const T& v) noexcept { return static_cast<Int>(v); }
  };
# endif

  // integer

  template <typename T, bool = is_unsigned_v<T>>
  struct fit_integer
  {
    using type = smaller_t<T,unsigned int,unsigned long long int>;
  };
  template <typename T> struct fit_integer<T,false>
  {
    using type = smaller_t<T,int,long long int>;
  };
} // __format

template<class Context, class... Args> struct format_arg_store;

template<class Context> class basic_format_arg {
public:
  class handle;

private:
  using char_type = typename Context::char_type;

  variant<
    monostate, bool, char_type, int, unsigned int,
    long long int, unsigned long long int, double, long double,
    const char_type*, basic_string_view<char_type>,
    const void*, handle> var;

  template<class X, class... Args>
  friend struct format_arg_store;

  // integer

  template <typename T, bool = is_integral_v<T>>
  struct integer : __format::fit_integer<T>
  {
    using typename __format::fit_integer<T>::type;
    type val(const T& v) const noexcept { return static_cast<type>(v); }
  };

  template <typename T> struct integer<T,false> {
    handle val(const T& v) const noexcept { return handle(v); }
  };

  template <typename T> struct identical {
    T val(T v) const noexcept { return v; }
  };

  template <typename T> struct best_store : integer<T> {};
  template <> struct best_store<bool> : identical<bool> {};
  template <> struct best_store<char> : identical<char> {};
  template <> struct best_store<wchar_t> : identical<wchar_t> {};
  template <> struct best_store<char8_t> : identical<char8_t> {};
  template <> struct best_store<char16_t> : identical<char16_t> {};
  template <> struct best_store<char32_t> : identical<char32_t> {};

  template<class T> explicit basic_format_arg(const T& v) noexcept
    : var(best_store<T>().val(v)) {}

  explicit basic_format_arg(float n) noexcept : var(static_cast<double>(n)) {}
  explicit basic_format_arg(double n) noexcept : var(n) {}
  explicit basic_format_arg(long double n) noexcept : var(n) {}
  explicit basic_format_arg(const char_type* s) : var(s) {}

  template<class Traits>
  explicit basic_format_arg(basic_string_view<char_type,Traits> s) noexcept
    : var(s) {}

  template<class Traits, class Allocator>
  explicit basic_format_arg(const basic_string<char_type,Traits,Allocator>& s) noexcept
    : basic_format_arg(basic_string_view(s.data(), s.size())) {}

  explicit basic_format_arg(nullptr_t) noexcept
    : var(static_cast<const void*>(nullptr)) {}

  explicit basic_format_arg(const void* p) noexcept
    : var(p) {}

  template<class Visitor, class Ctx>
  friend auto visit_format_arg(Visitor&& visit, basic_format_arg<Ctx> arg)
    -> decltype(visit(0));

  template<class Ctx, class... Args>
  friend format_arg_store<Ctx, Args...> make_format_args(const Args&... args);

public:
  basic_format_arg() noexcept {}
  explicit operator bool() const noexcept {
    return !holds_alternative<monostate>(var);
  }
};

template<class Context>
class basic_format_arg<Context>::handle {
  friend class basic_format_arg<Context>;

  using char_type = typename Context::char_type;
  using parse_context = basic_format_parse_context<char_type>;

  template<typename T>
  using formatter = typename Context::template formatter_type<T>;

  const void* __v;
  void (*__f)(parse_context&, Context&, const void*);

  template<class T> explicit handle(const T& val) noexcept
    : __v(&val)
    , __f([](parse_context& parse_ctx, Context& format_ctx, const void* ptr) {
        formatter<T> __f;
        auto __p = static_cast<const T*>(ptr);
        parse_ctx.advance_to(__f.parse(parse_ctx));
        format_ctx.advance_to(__f.format(*__p, format_ctx));
      })
  {}

public:
  void format(parse_context& parse_ctx, Context& format_ctx) const
  { __f(parse_ctx, format_ctx, __v); }
};

template<class Visitor, class Ctx> inline auto
visit_format_arg(Visitor&& visitor, basic_format_arg<Ctx> arg)
  -> decltype(visitor(0)) { return visit(move(visitor), arg.var); }

namespace __format
{
  template <typename Iterator>
  inline Iterator&& reserve(Iterator&& it, size_t) { return it; }

  struct data final
  {
    static const uint64_t powers_of_10_64[];
    static const uint32_t zero_or_powers_of_10_32[];
    static const uint64_t zero_or_powers_of_10_64[];
    static const uint64_t pow10_significands[];
    static const int16_t pow10_exponents[];
    static const char digits[];
    static const char hex_digits[];
    template <typename Char> struct basic_color {
      static const Char foreground[];
      static const Char background[];
      static const Char reset[];
    };
    using color = basic_color<char>;
    using wcolor = basic_color<wchar_t>;
    data() = delete;
  };

  template <typename T> struct is_char : false_type {};
  template <> struct is_char<char> : true_type {};
  template <> struct is_char<wchar_t> : true_type {};
  template <> struct is_char<char8_t> : true_type {};
  template <> struct is_char<char16_t> : true_type {};
  template <> struct is_char<char32_t> : true_type {};

  template <typename Char>
  inline constexpr bool is_char_v = is_char<Char>::value;

  void as_string_view(...);

  template<typename Char, enable_if<is_char_v<Char>>>
  inline basic_string_view<Char>
  as_string_view(const Char* s) { return {s}; }

  template<typename Char, typename Traits, typename Allocator>
  inline basic_string_view<Char>
  as_string_view(const basic_string<Char,Traits,Allocator>& s)
  { return {s.data(), s.size()}; }

  template<typename Char, typename Traits>
  inline basic_string_view<Char>
  as_string_view(basic_string_view<Char,Traits> s)
  { return {s.data(), s.size()}; }

  template <typename S>
  struct is_string : is_class<decltype(as_string_view(declval<S>()))> {};
  template <> struct is_string<void> : false_type {};

  template<typename S>
  inline constexpr bool is_string_v = is_string<S>::value;

  template <typename Int> using uint_32_64_t =
    conditional_t<numeric_limits<Int>::digits <= 32,
                         uint32_t, uint64_t>;

  template <typename Int> using uint_32_128_t =
    conditional_t<numeric_limits<Int>::digits <= 64,
                         uint_32_64_t<Int>, __uint128_t>;

  template <typename Int> using uint_best_fit_t = uint_32_128_t<Int>;

  template <typename T, enable_if_t<numeric_limits<T>::is_signed,int> = 0>
  inline constexpr bool is_negative(T value) { return value < 0; }

  template <typename T, enable_if_t<!numeric_limits<T>::is_signed,int> = 0>
  inline constexpr bool is_negative(T) { return false; }
  
# ifdef __has_builtin(__builtin_clz)
  // Returns the number of decimal digits in n. Leading zeros are not counted
  // except for n == 0 in which case count_digits returns 1.
  inline int count_digits(uint64_t n) {
    // Based on http://graphics.stanford.edu/~seander/bithacks.html#IntegerLog10
    // and the benchmark https://github.com/localvoid/cxx-benchmark-count-digits.
    int t = (64 - __builtin_clz(n | 1)) * 1233 >> 12;
    return t - (n < data::zero_or_powers_of_10_64[t]) + 1;
  }
# else
  // Fallback version of count_digits used when __builtin_clz is not available.
  inline int count_digits(uint64_t n) {
    int count = 1;
    for (;;) {
      // Integer division is slow so do it for a group of four digits instead
      // of for every digit. The idea comes from the talk by Alexandrescu
      // "Three Optimization Tips for C++". See speed-test for a comparison.
      if (n < 10) return count;
      if (n < 100) return count + 1;
      if (n < 1000) return count + 2;
      if (n < 10000) return count + 3;
      n /= 10000u;
      count += 4;
    }
  }
# endif

  // Counts the number of digits in n. BITS = log2(radix).
  template <unsigned BITS, typename UInt>
  inline int count_digits(UInt n) {
    int num_digits = 0;
    do {
      ++num_digits;
    } while ((n >>= BITS) != 0);
    return num_digits;
  }

  template <> int count_digits<4>(uintptr_t n);

  template <typename Spec, typename Value>
  inline void write_char(const Spec& spec, Value value) {
    auto out = spec.format_context.out();
    *out++ = static_cast<typename Spec::char_type>(value);
    spec.format_context.advance_to(out);
  }

  template <typename Spec, typename Int>
  void write_decimal(const Spec& spec, Int value) {
    using char_type = typename Spec::char_type;
    using uint_type = uint_best_fit_t<Int>;
    auto absvalue = static_cast<uint_type>(value);
    auto negative = is_negative(value);
    auto num_digits = 0;
    auto out = spec.format_context.out();
    if (negative) {
      absvalue = 0 - absvalue;
      num_digits = count_digits(absvalue);
      reserve(out, static_cast<size_t>(num_digits) + 1);
      *out++ = static_cast<char_type>('-');
    } else {
      num_digits = count_digits(absvalue);
      reserve(out, static_cast<size_t>(num_digits));
    }
    _LIBCPP_ASSERT(num_digits >= 0, "bad number of digits");
    enum {
          // '-' and digits
          base_size = numeric_limits<uint_type>::digits10 + 1,
          // base size and thousands separators
          buffer_size = base_size + base_size / 3,
    };
    char_type buffer[buffer_size];
    auto end = buffer + buffer_size;
    auto ptr = end;
    while (absvalue >= 100) {
      // Integer division is slow so do it for a group of two digits instead
      // of for every digit. The idea comes from the talk by Alexandrescu
      // "Three Optimization Tips for C++". See speed-test for a comparison.
      //     -- fmtlib by Victor Zverovich
      unsigned index = static_cast<unsigned>((absvalue % 100) * 2);
      absvalue /= 100;
      *--ptr = static_cast<char_type>(data::digits[index + 1]);
      //add_thousands_sep(ptr);
      *--ptr = static_cast<char_type>(data::digits[index]);
      //add_thousands_sep(ptr);
    }
    if (absvalue < 10) {
      *--ptr = static_cast<char_type>('0' + absvalue);
    } else {
      unsigned index = static_cast<unsigned>(absvalue * 2);
      *--ptr = static_cast<char_type>(data::digits[index + 1]);
      //add_thousands_sep(buffer);
      *--ptr = static_cast<char_type>(data::digits[index]);
    }
    spec.format_context.advance_to(copy(ptr, end, out));
  }

  template <typename Spec, typename Float>
  void write_floating(const Spec& spec, Float value) {
#if 0
    if (!isfinite(value)) {
      const char * const str = isinf(value) 
        ? (spec.upper ? "INF" : "inf") 
        : (spec.upper ? "NAN" : "nan");
      auto out = spec.format_context.out();
      out = copy(str, str+3, out);
      if (spec.percentage)
        *++out = static_cast<typename Spec::char_type>('%');
      spec.format_context.advance_to(out);
      return;
    }
#endif
    auto out = spec.format_context.out();
    if (spec.percentage) {
      const auto& s = to_string(value*100);
      out = copy(s.begin(), s.end(), out);
      *++out = static_cast<typename Spec::char_type>('%');
    } else {
      const auto& s = to_string(value);
      out = copy(s.begin(), s.end(), out);
    }
    spec.format_context.advance_to(out);
  }

  template<typename Char,unsigned Base>
  struct integral_prefix {
    static constexpr basic_string_view<Char> value = "";
  };
  template<> struct integral_prefix<char,2> {
    static constexpr basic_string_view<char> value = "0b";
  };
  template<> struct integral_prefix<wchar_t,2> {
    static constexpr basic_string_view<wchar_t> value = L"0b";
  };
  template<> struct integral_prefix<char,8> {
    static constexpr basic_string_view<char> value = "0";
  };
  template<> struct integral_prefix<wchar_t,8> {
    static constexpr basic_string_view<wchar_t> value = L"0";
  };
  template<> struct integral_prefix<char,16> {
    static constexpr basic_string_view<char> value = "0x";
  };
  template<> struct integral_prefix<wchar_t,16> {
    static constexpr basic_string_view<wchar_t> value = L"0x";
  };

  template<typename Char> inline Char upper_char(Char c) {
    return static_cast<Char>(toupper(c));
  }

  template<typename Char, typename Iterator>
  bool plus_sign(Iterator& out, bool negative) {
    *out++ = static_cast<Char>(negative ? '-' : '+');
    return true;
  }

  template<typename Char, typename Iterator>
  bool minus_sign(Iterator& out, bool negative) {
    if (negative) *out++ = static_cast<Char>('-');
    return negative;
  }

  template<typename Char, typename Iterator>
  bool space_sign(Iterator& out, bool negative) {
    *out++ = static_cast<Char>(negative ? '-' : ' ');
    return negative;
  }

  template<typename FormatContext>
  using handle_t = typename basic_format_arg<FormatContext>::handle;

  template<typename Value, unsigned Base> struct integral_traits {
    static constexpr auto digits = numeric_limits<Value>::digits * 3 / Base + 1;
    template<typename Iterator>
    inline static auto chars(Iterator begin, Iterator end, Value value)
    { return to_chars(begin, end, value, Base); }
  };
  template<typename Value> struct integral_traits<Value,0> {
    // digits and thousands separators
    // buffer_size = __traits::digits + __traits::digits / 3,
    static constexpr auto digits = numeric_limits<Value>::digits10+1;
    template<typename Iterator>
    inline static auto chars(Iterator begin, Iterator end, Value value)
    { return to_chars(begin, end, value); }
  };

  template<typename Char = char> struct bool_sv {
    auto __sv(bool value) const {
      return value
        ? basic_string_view<char>("true",4)
        : basic_string_view<char>("false",5);
    }
  };
  template<> struct bool_sv<wchar_t> {
    auto __sv(bool value) const {
      return value
        ? basic_string_view<wchar_t>(L"true",4)
        : basic_string_view<wchar_t>(L"false",5);
    }
  };

  template <typename T> using iterator_t = typename T::iterator;

  template <typename ParseContext>
  int positive_int(iterator_t<ParseContext>& pos, const iterator_t<ParseContext> end) {
    _LIBCPP_ASSERT(pos != end && '0' <= *pos && *pos <= '9', "parsing non-digits");
    if (*pos == '0') {
      ++pos;
      return 0;
    }
    unsigned val = 0;
    unsigned max = std::numeric_limits<int>::max();
    unsigned top = max / 10;
    do {
      val = val * 10 + unsigned(*pos - '0');
      ++pos;
      if (val > top) { // overflow
        val = top + 1;
        break;
      }
    } while (pos != end && '0' <= *pos && *pos <= '9');
    return static_cast<int>(val);
  }

  template <typename Char, typename OutIter> class driver final {
  public:
    using FormatContext = basic_format_context<OutIter,Char>;

    static_assert(is_same<OutIter,typename FormatContext::iterator>());

  private:
    FormatContext& format_context;

    void escape(Char character) {
      auto out = format_context.out();
      *out = character;
      ++out;
      format_context.advance_to(out);
    }

    template <typename ParseContext>
    void chars(ParseContext& parse_context, iterator_t<ParseContext>& pos, const iterator_t<ParseContext> end) {
      auto out = copy(pos, end, format_context.out());
      format_context.advance_to(out);
    }

    template <typename ParseContext>
    auto arg_id(ParseContext& parse_context, iterator_t<ParseContext>& pos, const iterator_t<ParseContext> end) {
      size_t id;
      auto c = *pos;
      if ('0' <= c && c <= '9') {
        id = positive_int<ParseContext>(pos, end);
        parse_context.check_arg_id(id);
      } else {
        id = parse_context.next_arg_id();
      }
      return id;
    }

    template <typename ParseContext>
    void replacement(ParseContext& parse_context, iterator_t<ParseContext>& pos, const iterator_t<ParseContext> end) {
      const auto id = this->arg_id(parse_context, pos, end);
      if (pos == end) {
        __THROW_FORMAT_ERROR("malform format string");
      } else if (*pos == ':') {
        ++pos;
      }
      parse_context.advance_to(pos);
      replace_arg(parse_context, id);
      pos = parse_context.begin();
    }

    template <typename ParseContext>
    void replace_arg(ParseContext& parse_context, size_t __id) {
      visit_format_arg([this, &parse_context](const auto &__v){
        replace(parse_context, __v);
      }, format_context.arg(__id));
    }

    template <typename ParseContext, typename Value>
    void replace(ParseContext& parse_context, const Value& __v) {
      formatter<remove_cvref_t<decltype(__v)>> __f;
      auto pos = __f.parse(parse_context);
      if (pos == parse_context.end())
        __THROW_FORMAT_ERROR("malform format spec");
      else if (*pos != '}')
        __THROW_FORMAT_ERROR("format spec without right brace '}'");
      parse_context.advance_to(++pos);
      format_context.advance_to(__f.format(__v, format_context));
    }

    template <typename ParseContext>
    void replace(ParseContext& parse_context, const handle_t<FormatContext>& __h) {
      __h.format(parse_context, format_context);
    }

  public:
    constexpr explicit driver(FormatContext& fc) : format_context(fc) {}

    template <typename ParseContext>
    constexpr OutIter operator()(ParseContext& parse_context) {
      auto const end = parse_context.end();
      auto pos = parse_context.begin();
      auto last = pos;
      while (pos != end) {
        switch (*pos) {
        case '{': {
          if (last < pos) this->chars(parse_context, last, pos);
          auto next = pos + 1;
          if (next == end) {
            // finish
          } else if (*next == '{') {
            ++next;
            this->escape(*pos);
            pos = next;
          } else {
            if (++pos == end)
              __THROW_FORMAT_ERROR("malform format string");
            this->replacement(parse_context, pos, end);
          }
          last = pos;
        } break;
        case '}': { // unbalanced close brace
          if (last < pos) this->chars(parse_context, last, pos);
          auto next = pos + 1;
          if (next == end) {
            pos = end; // finish
          } else if (*next == '}') {
            ++next;
            this->escape(*pos);
            last = pos = next;
          } else {
            this->chars(parse_context, pos, next);
            last = pos = end;
          }
        } break;
        default: ++pos;
        }
      }
      if (last < pos) this->chars(parse_context, last, pos);
      parse_context.advance_to(pos);
      return format_context.out();
    }

    OutIter __lit(size_t __n)
    {
      basic_format_parse_context<char> __fake("}"); // mimics "{}"
      const auto __begin = __fake.begin();
      for (auto __i = 0; __i < __n; ++__i) {
        if (__i > 0) {
          auto out = format_context.out();
          *out++ = static_cast<Char>(' ');
          format_context.advance_to(out);
        }
        __fake.advance_to(__begin);
        replace_arg(__fake, __i);
      }
      return format_context.out();
    }
  };

  template <typename Type, typename Char>
  class builtin_formatter
  {
  protected:
    enum {
          default_align, left_align, right_align,
          numeric_align, center_align
    } align : 3 = default_align;
    enum {
          default_sign, plus_sign, minus_sign, space_sign
    } sign : 2 = default_sign;
    Char type = 0;
    Char fill = static_cast<Char>(' ');
    int width : 16 = 0; // minimum field width
    int precision : 16 = -1;
    unsigned base : 5 = 0;
    bool hash : 1 = false;
    bool zero : 1 = false;
    bool upper : 1 = false;
    bool percentage : 1 = false;
    //chars_format fmt = chars_format::general;

    template <typename C> inline bool set_align(C __c) {
      auto result = true;
      switch (__c) {
      case '<': align = left_align;     break;
      case '>': align = right_align;    break;
      case '=': align = numeric_align;  break;
      case '^': align = center_align;   break;
      default:  result = false;         break;
      }
      return result;
    }

    template <typename C> inline void set_type(C __c) {
      switch ((type = __c)) {
      case 'a': //fmt = chars_format::hex;
        if (!is_floating_point_v<Type>)
          __THROW_FORMAT_ERROR("needs floating point");
        break;
      case 'A': //fmt = chars_format::hex;
        if (!is_floating_point_v<Type>)
          __THROW_FORMAT_ERROR("needs floating point");
        upper = true;
        break;
      case 'b':
        if (!is_integral_v<Type>)
          __THROW_FORMAT_ERROR("needs integral type");
        base = 2;
        break;
      case 'B':
        if (!is_integral_v<Type>)
          __THROW_FORMAT_ERROR("needs integral type");
        base = 2;
        upper = true;
        break;
      case 'c':
        if (!is_char_v<Type>)
          __THROW_FORMAT_ERROR("needs char type");
        break;
      case 'd':
        if (!is_integral_v<Type>)
          __THROW_FORMAT_ERROR("needs integral type");
        base = 10;
        break;
      case 'e': //fmt = chars_format::scientific;
        if (!is_floating_point_v<Type>)
          __THROW_FORMAT_ERROR("needs floating point");
        break;
      case 'E': //fmt = chars_format::scientific;
        if (!is_floating_point_v<Type>)
          __THROW_FORMAT_ERROR("needs floating point");
        upper = true;
        break;
      case 'f': //fmt = chars_format::fixed;
        if (!is_floating_point_v<Type>)
          __THROW_FORMAT_ERROR("needs floating point");
        break;
      case 'F': //fmt = chars_format::fixed;
        if (!is_floating_point_v<Type>)
          __THROW_FORMAT_ERROR("needs floating point");
        upper = true;
        break;
      case 'g': //fmt = chars_format::general;
        if (!is_floating_point_v<Type>)
          __THROW_FORMAT_ERROR("needs floating point");
        break;
      case 'G': //fmt = chars_format::general;
        if (!is_floating_point_v<Type>)
          __THROW_FORMAT_ERROR("needs floating point");
        upper = true;
        break;
      case 'n':
        if (!is_arithmetic_v<Type>)
          __THROW_FORMAT_ERROR("needs arithmetic type");
        break;
      case 'o':
        if (!is_integral_v<Type>)
          __THROW_FORMAT_ERROR("needs integral type");
        base = 8;
        break;
      case 'p':
        if (!is_pointer_v<Type>)
          __THROW_FORMAT_ERROR("needs pointer type");
        break;
      case 's':
        if (!is_string_v<Type>)
          __THROW_FORMAT_ERROR("needs string type");
        break;
      case 'x':
        if (!is_integral_v<Type>)
          __THROW_FORMAT_ERROR("needs integral type");
        base = 16;
        break;
      case 'X':
        if (!is_integral_v<Type>)
          __THROW_FORMAT_ERROR("needs integral type");
        base = 16;
        upper = true;
        break;
      case '%':
        if (!is_arithmetic_v<Type>)
          __THROW_FORMAT_ERROR("needs arithmetic type");
        break;
      }
    }

    bool check_padding(bool arithmetic) const {
      const auto result = align == numeric_align; // '=' alignment
      if (result && !arithmetic)
        __THROW_FORMAT_ERROR("'=' with non-arithmetic type");
      return result;
    }

    template<typename Iterator, typename Distance>
    auto padding_left(Iterator out, Distance& len, bool __on) const {
      switch (align) {
      case left_align:
        break;
      case right_align:
        if (/*width &&*/ width > len) {
          out = fill_n(out, width - len, this->fill);
        }
        break;
      case numeric_align:
        if (__on && /*width &&*/ width > len) {
          out = fill_n(out, width - len, this->fill);
        }
        break;
      case center_align:
        if (/*width &&*/ width > len) {
          out = fill_n(out, (width - len)/2, this->fill);
        }
        break;
      default: // default_align
        if (__on && /*width &&*/ width > len) {
          out = fill_n(out, width - len, this->fill);
        }
      }
      return out;
    }

    template<typename Iterator, typename Distance>
    auto padding_right(Iterator out, Distance& len, bool __on) const {
      switch (align) {
      case left_align:
        if (/*width &&*/ width > len) {
          out = fill_n(out, width - len, this->fill);
        }
        break;
      case right_align:
        break;
      case numeric_align:
        break;
      case center_align:
        if (/*width &&*/ width > len) {
          out = fill_n(out, width - (width - len)/2, this->fill);
        }
        break;
      default: // default_align
        if (__on && /*width &&*/ width > len) {
          out = fill_n(out, width - len, fill);
        }
        break;
      }
      return out;
    }

    template<unsigned Base, typename Iterator, typename Distance>
    auto padding_integral_prefix(Iterator out, Distance& len, bool negative) const {
      auto is_num = this->check_padding(true);
      auto has_sign = false;
      switch (sign) {
      case plus_sign:
        *out++ = static_cast<Char>(negative ? '-' : '+');
        has_sign = true;
        len += 1;
        break;
      case minus_sign:
        if (negative) {
          *out++ = static_cast<Char>('-');
          has_sign = true;
          len += 1;
        }
        break;
      case space_sign:
        *out++ = static_cast<Char>(negative ? '-' : ' ');
        has_sign = negative;
        len += 1;
        break;
      }
      if (hash) {
        auto __s = integral_prefix<Char,Base>::value;
        len += __s.size();
        if (!zero && !is_num)
          out = this->padding_left(out, len, true);
        if ((Base == 16 || Base == 2) && upper)
          out = transform(__s.begin(), __s.end(), out, upper_char<Char>);
        else
          out = copy(__s.begin(), __s.end(), out);
      }
      if ((zero || (is_num && has_sign)) && width > len)
        out = fill_n(out, width - len, static_cast<Char>('0'));
      else if (!hash)
        out = this->padding_left(out, len, true);
      return out;
    }

    template<typename Iterator, typename Distance>
    auto padding_nonarith_prefix(Iterator out, Distance& len) const {
      this->check_padding(false);
      out = this->padding_left(out, len, false);
      return out;
    }

  public:
    template <typename ParseContext>
    constexpr auto parse(ParseContext& context) -> decltype(context.begin())
    {
      auto pos = context.begin(), end = context.end();
      if (pos == end) {
        __THROW_FORMAT_ERROR("malform format spec");
      } else if (*pos == '}') {
        align = default_align;
        return pos;
      } else if (auto next = pos + 1; next != end) {
        if (set_align(*next)) {
          if ((fill = *pos) == '{')
            __THROW_FORMAT_ERROR("invalid fill character '{'");
          pos += 2;
        } else if (set_align(*pos)) {
          pos = next;
        }
        if (pos == end)
          __THROW_FORMAT_ERROR("malform format spec");
        else switch (*pos) {
          case '+':
            sign = plus_sign;
            ++pos;
            break;
          case '-':
            sign = minus_sign;
            ++pos;
            break;
          case ' ':
            sign = space_sign;
            ++pos;
            break;
          }
        if (pos == end) {
          __THROW_FORMAT_ERROR("malform format spec");
        } else if (*pos == '#') {
          hash = true;
          ++pos;
        }
        if (pos == end) {
          __THROW_FORMAT_ERROR("malform format spec");
        } else if (*pos == '0') {
          zero = true;
          ++pos;
        }
        if (pos == end) {
          __THROW_FORMAT_ERROR("malform format spec");
        } else if ('1' <= *pos && *pos <= '9') {
          width = positive_int<ParseContext>(pos, end);
        }
        if (pos != end && *pos == '.') {
          if (++pos == end) {
            __THROW_FORMAT_ERROR("malform format spec");
          } else {
            precision = positive_int<ParseContext>(pos, end);
          }
        }
        if (pos == end)
          __THROW_FORMAT_ERROR("malform format spec");
        if (const auto type = *pos; type != '}') {
          ++pos; // presentation type
          set_type(type);
        }
      } else {
        __THROW_FORMAT_ERROR("malform format spec");
      }
      return pos;
    }
  };

  template <typename Int, typename Char>
  struct integral_formatter : builtin_formatter<Int,Char>
  {
    template <typename FormatContext>
    constexpr typename FormatContext::iterator
    format(Int value, FormatContext& context)
    {
      auto __o = context.out();
      switch (this->base) {
      case  0: __o = __fmt<0>(value, __o);  break;
      case  2: __o = __fmt<2>(value, __o);  break;
      case  8: __o = __fmt<8>(value, __o);  break;
      case 10: __o = __fmt<10>(value, __o); break;
      case 16: __o = __fmt<16>(value, __o); break;
      default: __THROW_FORMAT_ERROR("integer with wrong base");
      }
      context.advance_to(__o);
      return __o;
    }
  private:
    template <unsigned Base, typename Iterator>
    constexpr auto __fmt(Int value, Iterator __o) const
    {
      using __traits = integral_traits<Int,Base>;
      enum { size = __traits::digits };
      Char buffer[size];
      auto res = __traits::chars(buffer, buffer+size, value);
      if (res.ec != errc(0))
        __THROW_FORMAT_ERROR("format integer value error");
      else {
        auto len = distance(buffer, res.ptr);
        __o = this->template padding_integral_prefix<Base>(__o, len, value < 0);
        if (Base == 16 && this->upper)
          __o = transform(buffer, res.ptr, __o, upper_char<Char>);
        else
          __o = copy(buffer, res.ptr, __o);
        if (!this->zero)
          __o = this->padding_right(__o, len, false);
      }
      return __o;
    }
  };

  template <typename T, typename Char>
  struct bool_formatter : builtin_formatter<T,Char>
  {
    template <typename FormatContext>
    constexpr typename FormatContext::iterator
    format(T value, FormatContext& context)
    {
      auto __o = context.out();
      switch (this->base) {
      case  0:
        __o = (this->type)
          ? __fmt<10>(value, __o)
          : __fmt_sv(value, __o);
        break;
      case  2: __o = __fmt<2>(value, __o); break;
      case  8: __o = __fmt<8>(value, __o); break;
      case 10: __o = __fmt<10>(value, __o); break;
      case 16: __o = __fmt<16>(value, __o); break;
      default: __THROW_FORMAT_ERROR("bool with wrong base");
      }
      context.advance_to(__o);
      return __o;
    }
  private:
    template <unsigned Base, typename Iterator>
    constexpr auto __fmt(T value, Iterator __o) const
    {
      unsigned len = 1;
      __o = this->template padding_integral_prefix<Base>(__o, len, false);
      *__o++ = static_cast<Char>(value ? '1' : '0');
      __o = this->padding_right(__o, len, false);
      return __o;
    }
    template <typename Iterator>
    constexpr auto __fmt_sv(T value, Iterator __o) const
    {
      auto __s = bool_sv<Char>().__sv(value);
      auto len = __s.size();
      __o = this->padding_nonarith_prefix(__o, len);
      __o = copy(__s.begin(), __s.end(), __o);
      __o = this->padding_right(__o, len, true);
      return __o;
    }
  };

  template <typename T,typename Char>
  struct char_formatter : builtin_formatter<T,Char>
  {
    template <typename FormatContext>
    constexpr typename FormatContext::iterator
    format(T value, FormatContext& context)
    {
      auto __o = context.out();
      if (this->base > 0) {
        integral_formatter<int,Char> __f;
        __o = __f.format(static_cast<int>(value), context);
      } else {
        unsigned len = 1;
        __o = this->padding_nonarith_prefix(__o, len);
        *__o++ = static_cast<Char>(value); // FIXME: unicode charconv
        __o = this->padding_right(__o, len, true);
      }
      context.advance_to(__o);
      return __o;
    }
  };

  template <typename Char> struct integral_formatter<bool,Char> : bool_formatter<bool,Char> {};
  template <typename Char> struct integral_formatter<char,Char> : char_formatter<char,Char> {};
  template <typename Char> struct integral_formatter<wchar_t,Char> : char_formatter<wchar_t,Char> {};

  string __spf(double __v, char __t, int __precision, bool __alt);
  string __spf(long double __v, char __t, int __precision, bool __alt);
  wstring __spf(double __v, wchar_t __t, int __precision, bool __alt);
  wstring __spf(long double __v, wchar_t __t, int __precision, bool __alt);

  template <typename Float, typename Char>
  struct floating_formatter : builtin_formatter<Float,Char>
  {
    template <typename FormatContext>
    constexpr typename FormatContext::iterator
    format(Float __v, FormatContext& context)
    {
      return __fmt_spf(__v, context);
    }

  private:
    template <typename FormatContext>
    constexpr typename FormatContext::iterator
    __fmt_tc(Float __v, FormatContext& context)
    {
      basic_string<Char> __s;
      // TODO: to_chars(...)
      return context.begin();
    }

    template <typename FormatContext>
    constexpr typename FormatContext::iterator
    __fmt_spf(Float __v, FormatContext& context)
    {
      if (this->percentage)
        __v *= 100;
      auto __s = __spf(__v, this->type, this->precision, this->hash);
      auto __o = context.out();
      __o = copy(__s.begin(), __s.end(), __o);
      if (this->percentage)
        *__o++ = static_cast<Char>('%');
      context.advance_to(__o);
      return __o;
    }
  };

  template <typename P, typename Char>
  struct pointer_formatter : builtin_formatter<P,Char>
  {
    template <typename FormatContext>
    constexpr typename FormatContext::iterator
    format(P value, FormatContext& context)
    {
      using __traits = integral_traits<uintptr_t,16>;
      enum { size = __traits::digits };
      Char __buf[size];
      auto __v = reinterpret_cast<uintptr_t>(value);
      auto res = __traits::chars(__buf, __buf+size, __v);
      if (res.ec != errc(0))
        __THROW_FORMAT_ERROR("format integer value error");
      else {
        auto out = context.out();
        *out++ = static_cast<Char>('0');
        *out++ = static_cast<Char>(this->upper ? 'X' : 'x');
        out = copy(__buf, res.ptr, out);
        context.advance_to(out);
      }
      return context.out();
    }
  };

  template <typename S, typename Char> struct string_formatter;
  template <typename C, typename Char>
  struct string_formatter<basic_string_view<C>,Char>
    : builtin_formatter<basic_string_view<C>,Char>
  {
    template <typename FormatContext>
    constexpr typename FormatContext::iterator
    format(basic_string_view<C> value, FormatContext& context)
    {
      auto len = distance(value.begin(), value.end());
      auto out = context.out();
      out = this->padding_nonarith_prefix(out, len);
      out = copy(value.begin(), value.end(), out);
      out = this->padding_right(out, len, true);
      context.advance_to(out);
      return out;
    }
  };

  template <typename C,typename Char>
  struct string_formatter<basic_string<C>,Char>
    : string_formatter<basic_string_view<C>,Char>
  {
    template <typename FormatContext>
    constexpr typename FormatContext::iterator
    format(const basic_string<C>& value, FormatContext& context)
    { return this->string_formatter<basic_string_view<C>,Char>::format(basic_string_view<C>(value), context); }
  };

  template <typename Char>
  struct string_formatter<const char*,Char>
    : string_formatter<basic_string_view<char>,Char>
  {
    template <typename FormatContext>
    constexpr typename FormatContext::iterator
    format(const char* value, FormatContext& context)
    { return this->string_formatter<basic_string_view<char>,Char>::format(basic_string_view<char>(value), context); }
  };

  template <typename Char>
  struct string_formatter<const wchar_t*,Char>
    : string_formatter<basic_string_view<wchar_t>,Char>
  {
    template <typename FormatContext>
    constexpr typename FormatContext::iterator
    format(const wchar_t* value, FormatContext& context)
    { return this->string_formatter<basic_string_view<wchar_t>,Char>::format(basic_string_view<wchar_t>(value), context); }
  };
} // __format

template<class Context, class... Args>
struct format_arg_store {
  array<basic_format_arg<Context>,sizeof...(Args)> args;
  format_arg_store(const Args&... args)
    : args{ basic_format_arg<Context>(args)... } {}
};

template<class Context = format_context, class... Args>
inline format_arg_store<Context,Args...>
make_format_args(const Args&... args) { return {args...}; }

template<class... Args>
inline format_arg_store<wformat_context,Args...>
make_wformat_args(const Args&... args) { return {args...}; }

template<class Context> class basic_format_args {
  const basic_format_arg<Context>* args;
  size_t num_args;

public:
  basic_format_args() noexcept;

  template<class... Args>
  basic_format_args(const format_arg_store<Context,Args...>& store) noexcept
    : args(store.args.data()), num_args(store.args.size()) {}

  basic_format_arg<Context> get(size_t i) const noexcept
  { return i < num_args ? args[i] : basic_format_arg<Context>(); }
};

template<typename Char>
struct formatter<monostate,Char>
  : __format::builtin_formatter<monostate,Char>
{
  template <typename FormatContext>
  constexpr typename FormatContext::iterator
  format(monostate, FormatContext& context) { return context.out(); }
};

template<typename Char> struct formatter<int,Char>
  : __format::integral_formatter<int,Char> {};

template<typename Char> struct formatter<bool,Char>
  : __format::integral_formatter<bool,Char> {};

template<typename Char> struct formatter<char,Char>
  : __format::integral_formatter<char,Char> {};

template<typename Char> struct formatter<wchar_t,Char>
  : __format::integral_formatter<wchar_t,Char> {};

template<typename Char> struct formatter<unsigned int,Char>
  : __format::integral_formatter<unsigned int,Char> {};

template<typename Char> struct formatter<long long,Char>
  : __format::integral_formatter<long long,Char> {};

template<typename Char> struct formatter<unsigned long long,Char>
  : __format::integral_formatter<unsigned long long,Char> {};

template<typename Char> struct formatter<double,Char>
  : __format::floating_formatter<double,Char> {};

template<typename Char> struct formatter<long double,Char>
  : __format::floating_formatter<long double,Char> {};

template<typename Char> struct formatter<const char*,Char>
  : __format::string_formatter<const char*,Char> {};

template<typename Char> struct formatter<const wchar_t*,Char>
  : __format::string_formatter<const wchar_t*,Char> {};

template<typename C, typename Char>
struct formatter<basic_string_view<C>,Char>
  : __format::string_formatter<basic_string_view<C>,Char> {};

template<typename C, typename Char>
struct formatter<basic_string<C>,Char>
  : __format::string_formatter<basic_string<C>,Char> {};

template<typename Char> struct formatter<const void*,Char>
  : __format::pointer_formatter<const void*,Char> {};

template<typename T,typename Char>
struct formatter<T*,Char> : formatter<const void*,Char>
{
  template <typename FormatContext>
  constexpr typename FormatContext::iterator
  format(T* value, FormatContext& context) {
    return this->formatter<const void*,Char>::format(reinterpret_cast<const void*>(value), context);
  }
};

namespace __format
{
  template<typename Char>
  using basic_string_format_args = basic_format_args<basic_string_format_context<Char>>;

  template<typename S, typename=void> struct associated_char {};
  template<typename S> struct associated_char<S,enable_if_t<is_string_v<S>>> {
    using string_view = decltype(as_string_view(declval<S>()));
    using type = typename string_view::value_type;
  };

  template <typename S>
  using char_t = typename associated_char<S>::type;
} // __format

using format_args = __format::basic_string_format_args<char>;
using wformat_args = __format::basic_string_format_args<wchar_t>;

template<typename Out, typename Char>
using format_args_t = basic_format_args<basic_format_context<Out,Char>>;

template <typename Out, typename S, typename Char = __format::char_t<S>>
inline Out vformat_to(Out __out, const S& __fmt, format_args_t<Out,Char> __args) {
  using driver = __format::driver<Char,Out>;
  typename driver::FormatContext __format_context(__out, __args);
  basic_format_parse_context<Char> __parse_context(__fmt);
  return driver(__format_context)(__parse_context);
}

template<class S, class Context, typename Char = __format::char_t<S>>
inline auto vformat(const S& __fmt, basic_format_args<Context> __args) {
  basic_string<Char> __buf;
  __format::basic_string_inserter<Char> __out(__buf);
  vformat_to(__out, __fmt, __args);
  return __buf;
}

template<typename S, typename... Args, typename Char = __format::char_t<S>>
inline auto format(const S& fmt, const Args&... args) {
  using Context = __format::basic_string_format_context<Char>;
  auto store = make_format_args<Context>(args...);
  const basic_format_args<Context> va(store);
  return vformat(fmt, va);
}

template<typename Char, int N, class... Args>
inline auto format(const Char fmt[N], const Args&... args) {
# if 0
  return format(__format::as_string_view(fmt), args...);
# else
  return format(basic_string_view<Char>(fmt,N), args...);
# endif
}

template<typename Char, class... Args>
inline auto format(const Char* fmt, const Args&... args) {
# if 0
  return format(__format::as_string_view(fmt), args...);
# else
  return format(basic_string_view<Char>(fmt), args...);
# endif
}

_LIBCPP_END_NAMESPACE_STD

#undef __FORMAT_ERROR_MSX
#undef __FORMAT_ERROR_MSG
#undef __THROW_FORMAT_ERROR
